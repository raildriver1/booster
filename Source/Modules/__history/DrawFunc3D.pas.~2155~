//----------------------------------------------------------------------------//
//DRON's OpenGl Engine V 1.0 http://dronprogs.mirgames.ru                     //
//                                                                            //
// GLDrawFunc3D.pas V 1.1, 13.04.2008                                         //
//                                                                            //
// This module provides all basic 3D graphics routines.                       //
//                                                                            //
// Copyright (C) 2005-2006 Korotkov Andrew aka DRON                           //
//                                                                            //
//This program is free software; you can redistribute it and/or               //
//modify it under the terms of the GNU General Public License                 //
//as published by the Free Software Foundation; either version 2              //
//of the License, or any later version.                                       //
//                                                                            //
//This program is distributed in the hope that it will be useful,             //
//but WITHOUT ANY WARRANTY; without even the implied warranty of              //
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               //
//GNU General Public License (http://www.gnu.org/copyleft/gpl.html)           //
//for more details.                                                           //
//----------------------------------------------------------------------------//
unit DrawFunc3D;
interface
uses OpenGL, Variables, Windows, TFrustumClass, EngineUtils, SysUtils, DMD_MultyMesh,
     Textures, DPC_Packages, Classes, KlubData, KlubProcessor, Math, TlHelp32,   MMSystem;


type TVertex3D = record X,Y,Z : single; Color, Alpha : integer; TexX, TexY : single; end;

     TCamera = record
          Eye    : TVertex;
          Center : TVertex;
          end;

     TObj3DInfo = record
          Texture : cardinal;
          Color : Array [1..4] of GLFloat;
          Projecting : boolean;
          end;

      TSceneMesh = record
          Active      : boolean;
          Name        : string[128];
          Pos         : Tvertex;
          Scale       : single;
          Material    : TMaterial;
          Texture     : cardinal;
          DoBump      : boolean;
          BumpTexture : cardinal;
          SpecTexture : cardinal;
          MeshFrame   : cardinal;
          MeshSmooth  : boolean;
          Mesh        : cardinal;
          end;

      TMeshGeometry = record
          VerticesCount, FacesCount : cardinal;
          Vertices, Normals : array of TVertex;
          Tangents : array of TTangent;
          Faces : array of array[0..2] of cardinal;
          TextureVertices : array of TVertex;
          TextureFaces : array of array[0..2] of cardinal;
          end;
      PMeshGeometry = ^TMeshGeometry;

procedure BeginObj3D; stdcall;
procedure EndObj3D; stdcall;
procedure Position3D(X,Y,Z : single); stdcall;
procedure Position2D(X,Y : integer); stdcall;
procedure SetTexture(Texture : gluint); stdcall;
procedure Color3D(Color:integer; Alpha : byte; Diffuse : boolean; MaterialShininess : single); stdcall;
procedure AdductingMatrix3Dto2D; stdcall;
procedure ReturnStandartMatrix3D; stdcall;
procedure DrawAxes(Length : single = 1.0); stdcall;
procedure RotateX(Angle : single); stdcall;
procedure RotateY(Angle : single); stdcall;
procedure RotateZ(Angle : single); stdcall;
procedure Scale3D(Scale : single); stdcall;
procedure DrawPlane(Width,Height : single); stdcall;
procedure DrawSphere(Radius : single); stdcall;
procedure DrawLine(X,Y,Z,X1,Y1,Z1 : single; LineWidth : real = 1.0; Smooth : boolean = true); stdcall;
procedure DrawPoint(X,Y,Z : single); stdcall;
function  LoadModel(Filename : string; ScaleType : byte; NormalInv : boolean) : integer; stdcall;
procedure FreeModel(ModelIdent : integer); stdcall;
procedure DrawModel(ModelIdent, Frame : integer; Smooth : boolean); stdcall;
procedure GetModelGeometry(ModelIdent, Frame : integer; GeometryData : PMeshGeometry); stdcall;
procedure EnableSphereMapping; stdcall;
procedure DisableSphereMapping; stdcall;
procedure SetLight(ID : integer; X,Y,Z : single; LightColor : integer; Radius : single; Visualize : boolean; Scale : single); stdcall;
procedure DrawEllipse(Width,Height,Depth : single); stdcall;
function  CreateTextureToRenderIn(TextureWidth,TextureHeight : integer):GlUint; stdcall;
procedure StartRenderToTexture(Texture : GlUint); stdcall;
procedure EndRenderToTexture; stdcall;
procedure DrawSprite(Width,Height : single; FramesXCount, FramesYCount, FrameNumber: integer);stdcall;
procedure DrawCylinder(Radius,Height : single); stdcall;
procedure DrawPolygon3D(points : array of TVertex3D); stdcall;
function  ModelFramesCount(Modelident : integer):Integer; stdcall;
procedure DeactiveLight(ID : integer); stdcall;
function  ModelBoundingBox(Modelident,Frame : integer):TVertex; stdcall;
function  ModelTrianglesCount(Modelident,Frame : integer) : Cardinal; stdcall;
procedure DrawSprite_BillBoard(Width,Height : single; FramesXCount, FramesYCount, FrameNumber: integer);stdcall;
procedure ActivateMultitexturingLayer(Layer : Cardinal); stdcall;
procedure DeactiveMultytexturing; stdcall;
procedure SetMultytexturingLayerOffset(Layer : cardinal; X,Y : single); stdcall;
procedure ClearZBuffer; stdcall;
procedure DrawCube(Width,Height,Depth : single); stdcall;
procedure SetFog(Color : Integer; Fog_Start, Fog_End : single); stdcall;
procedure DeactiveFog; stdcall;
procedure SetCamera(Camera : TCamera); stdcall;
procedure CalculateFrustum; stdcall;
function  IsPointInFrustum(X,Y,Z : single) : boolean; stdcall;
function  IsSphereInFrustum(X,Y,Z,Radius : single) : boolean; stdcall;
function  IsBoxInFrustum(X,Y,Z,W,H,D : single) : boolean; stdcall;
procedure ZBuffer(Active : boolean); stdcall;
procedure ResetMatrix; stdcall;
procedure DrawTextureToTexture(TexSource,TexTarget : GluInt; X,Y : integer); stdcall;
procedure SetMultytexturingLayerTexCoordMulti(Layer : cardinal; X,Y : single); stdcall;
procedure DrawTextureToTextureTransparentColor(TexSource,TexTarget : GluInt; X,Y : integer; Color : Cardinal); stdcall;
function  ModelMaterial(Modelident : integer) : TMaterial; stdcall;
procedure CullFace(Mode : cardinal); stdcall;
procedure ModelsBump(Active : boolean); stdcall;
procedure RenderTexToTexFBO(ToTexture,TexSource,TexTarget : GluInt; X,Y : integer); stdcall;

function  LoadScene(FileName, MeshPath, TexPath : string):cardinal; stdcall;
procedure FreeScene(Ident : cardinal); stdcall;
procedure DrawScene(Ident : cardinal); stdcall;
function  SceneBoundingBox(Ident : cardinal):TVertex; stdcall;
function  CollideBoxWithScene(Ident : cardinal; BoxPos, BoxSize : Tvertex):boolean; stdcall;
function  SceneGetLastCollideObjectIndex:integer; stdcall;
function  SceneObjCount( Ident : cardinal ) : cardinal; stdcall;
function  GetSceneObjectIdent( SceneIdent : cardinal; ObjName : string ) : integer; stdcall;
procedure SceneSetObjActive( SceneIdent, ObjIdent : cardinal; Active : boolean ); stdcall;
procedure SceneSetObj( SceneIdent, ObjIdent : cardinal; SceneMesh : TSceneMesh ); stdcall;
function  SceneGetObj( SceneIdent, ObjIdent : cardinal ) : TSceneMesh; stdcall;

procedure WriteHookAddress; stdcall;
procedure ProcessFreecam; stdcall;
procedure LoadSettingsAndCustomModels; stdcall;
procedure ProcessDayNightSystem; stdcall;
procedure LoadConfigFile; stdcall;
var
  ConfigLoaded: Boolean;
procedure ApplyMaxVisibleDistance; stdcall;


procedure HookKLUB(
  x: Single;
  y: Single;
  z: Single;
  AngZ: Single
); stdcall; export;

exports
  HookKLUB;
procedure FreeEng;
procedure InitEng;

function  GETLIGHT(ID: integer) : integer;
procedure _glTexCoord2f(X,Y : GLFloat; Layer : integer = -1); stdcall;
procedure _glTexCoord3f(X,Y,Z : GLFloat; Layer : integer = -1);

const
  CustomModelPath: PChar = 'Data\loc\1.dmd';

var
LightsOn : array [0..20] of boolean;
QuadraticObject : PGLUQuadricObj;
SphereDL : glUint;
RenderTTWidth,RenderTTHeight : integer;
In2DWeAre : boolean = false;
CurTexture : cardinal = 0;

SettingsLoaded: Boolean = False;
LocNum: string = '';
LocomotiveType: Integer = 822;
CustomModelLoaded: Boolean = False;
CustomModelID: Integer = 0;
CustomTextureID: Cardinal = 0;

  SystemInitialized: Boolean = False;
  
  // Оптимизация времени
  LastTimeCheck: Cardinal = 0;
  TimeCheckInterval: Cardinal = 100; // раз в 100мс

StationsList: TStringList;
StationsLoaded: Boolean = False;
CurrentStationName: string = '';
NextStationName: string = '';

LastCollide : integer = -1;

Obj3DInfo : array of TObj3DInfo;
InBlock : boolean = false;

CantRenderInFBO : boolean;
fbo_frame : cardinal = 0;
fbo_depth : cardinal = 0;
fbo_w, fbo_h, fbo_z : cardinal;
fbo2 : cardinal;

implementation
uses Advanced3D, DrawFunc2D;

type TAMesh = record
Ident : cardinal;
Mesh : TGLMultyMesh;
end;



TScene = record
 uid : cardinal;
 Models : array of TSceneMesh;
end;

// ===== ДОБАВИТЬ В СЕКЦИЮ VAR ПЕРЕД IMPLEMENTATION =====
var
  LastStationUpdate: Cardinal = 0;
  StationUpdateInterval: Cardinal = 1000; // Обновлять каждую секунду
  // Переменные для выдвигающегося интерфейса
  KeyboardPanelExpanded: Boolean = False;
  KeyboardPanelAnimation: Single = 0.0;
  KeyboardPanelTargetWidth: Single = 0.0;
  LastMousePos: TPoint;

  FloatValueAddr: Cardinal = $00400000 + $8D1072C; // Адрес float значения
  LastFloatValue: Single = -999.0; // Для отслеживания изменений
  FloatAsInt: Integer;
  FloatStr: string;

    // Переменные конфигурации
  Config_SAUT: Boolean = True;   // Отображение элементов скорости и лимитов (14, 15, 16)
  Config_BGSD: Boolean = True;   // Отображение основных данных (0-13)
  Config_STUPEN: Boolean = True;  // ← ДОБАВИТЬ ЭТУ СТРОКУ

  // ===== НОВЫЕ ПЕРЕМЕННЫЕ ДЛЯ ФРИКАМА =====
  Config_BaseSpeed: Single = 0.0;        // Базовая скорость фрикама
  Config_FastSpeed: Single = 2.2;        // Быстрая скорость фрикама (Shift)
  Config_TurnSpeed: Single = 1.5;        // Скорость поворота камеры
  Config_MaxVisibleDistance: Integer = 820; // Максимальная дистанция видимости

const
  PANEL_BASE_WIDTH = 80;      // Базовая ширина панели
  PANEL_EXPANDED_WIDTH = 300; // Расширенная ширина
  PANEL_HEIGHT = 200;         // Высота панели
  PANEL_MARGIN = 10;          // Отступ от края экрана
  ANIMATION_SPEED = 8.0;      // Скорость анимации

  // Тип для хранения информации о станции
type
  TStationInfo = record
    name: string;
    piket: Integer;
    distance: Integer;
  end;

var
 RenderedTex : GlUint;
 MultyCoordOffset : array [1..5] of array [0..3] of GLfloat;

 Meshs : array of TAMesh;
 MeshsCount : cardinal = 0;
 OverAllMeshUsed :cardinal = 0;

 Scenes : array of TScene;
 ScenesCount : cardinal = 0;
 ScenesOverall : cardinal = 0;

 mat_shininess : GLfloat = 0.0;

   LastStationCheck: Cardinal = 0;
  StationCheckInterval: Cardinal = 2000; // каждые 2 секунды
  CachedCurrentStation: string = '';
  CachedNextStation: string = '';


   KeyDebounceTime: array[0..11] of Cardinal;
  DebounceInterval: Cardinal = 50; // 50мс задержка

 light_ambient : array [0..3] of GLfloat = ( 0.0, 0.0, 0.0, 1.0 );
 light_diffuse : array [0..3] of GLfloat = ( 1.0, 1.0, 1.0, 1.0 );
 light_specular : array [0..3] of GLfloat = ( 1.0, 1.0, 1.0, 1.0 );
 mat_specular : array [0..3] of GLfloat = ( 0.0, 0.0, 0.0, 1.0 );

   CachedYellowBlockID: Word = 0;
  CachedGreenBlockID: Word = 0;
  LightBlockIDsCached: Boolean = False;

  // Переменные для работы со светофорами
  s1, s2: TStringList;
  TrafficSystemInitialized: Boolean = False;
  HookAddressWritten: Boolean = False;

    LastSignalUpdate: Cardinal = 0;
  SignalUpdateInterval: Cardinal = 2000; // каждые 500мс
  CachedSignalSequence: string = '';

  // Глобальные переменные для обработки команд
  LastCommand: string = '';
  CommandBuffer: string = '';
  PointerAddress: Cardinal = $900421C;
  WindowOpenAddress: Cardinal = $00400000 + $4F8D915;

  // Массивы для отслеживания состояний клавиш
  PreviousKeyStates: array[0..11] of Byte;
  KeyStatesInitialized: Boolean = False;
  
  // Флаги для обработки команд  
  statek137: Boolean = False;
  statek10: Boolean = False;  // <- ДОБАВИТЬ ЭТУ СТРОКУ
  SavedCommand: string = '';
  CommandCompleted: Boolean = False;
  EnterPressed: Boolean = False;

  // Переменные для моделей
  MyModelID: integer = 0;
  MyTextureID: cardinal = 0;
  strelka: integer = 0;
  ImpactFont: Integer = 0;
  KLUBUFont: Integer = 0;        // ← ДОБАВИТЬ ЭТУ ПЕРЕМЕННУЮ

  LastKeyboardCheck: Cardinal = 0;
  KeyboardCheckInterval: Cardinal = 1; // ~60 FPS = каждые 16мс

  // Переменные переменных
  en_chastota: string = 'x';
  MemoryWritten: Boolean = False;

  als_en_state: Boolean = False;

  YellowBlockRotX: Single = 0.0;
  YellowBlockRotY: Single = 0.0;
  YellowBlockRotZ: Single = 0.0;
  YellowBlockPosX: Single = -0.086499996;
  YellowBlockPosY: Single = 0.0;
  YellowBlockPosZ: Single = 0.223;
  YellowBlockScale: Single = 0.88999999;
  YellowBlockParamsLoaded: Boolean = False;
  // Переменные для фрикамы
  FreecamEnabled: Boolean = False;
  FreecamInitialized: Boolean = False;

  // Переменные для параметров стрелки
  ArrowAngle: Single = 150.0;
  ArrowRotation: Single = 90.0;
  ArrowScale: Single = 1.61;
  ArrowX: Single = 0.895;
  ArrowY: Single = 7.45;
  ArrowZ: Single = 3.64;
  ArrowRotateX: Single = -40.4;
  ArrowRotateY: Single = 0.0;
  ArrowRotateZ: Single = 0.0;
  ArrowCurrentSpeed: Single = 0.0;
  ArrowKoef: Single = 1.63;
  ArrowParamsLoaded: Boolean = False;
  
  // ===== ПЕРЕМЕННЫЕ ДЛЯ РЕАЛ-ТАЙМ ОБНОВЛЕНИЯ =====
  LastArrowParamsCheck: Cardinal = 0;
  ArrowParamsCheckInterval: Cardinal = 500;
  LastBoosterConfigCheck: Cardinal = 0;
  BoosterConfigCheckInterval: Cardinal = 1000; // Реже обновляем настройки отображения
  
  // Адреса камеры
  ADDR_LOOKYAW: Cardinal = $9004398;
  ADDR_LOOKPITCH: Cardinal = $900439C;
  ADDR_X: Cardinal = $9008028;
  ADDR_Y: Cardinal = $900802C;
  ADDR_Z: Cardinal = $9008030;
  FREEMODE_SWITCH_ADDR: Cardinal = $7499E8;
  
  // Параметры движения
  BASE_SPEED: Single = 0.5;
  FAST_SPEED: Single = 2.2;
  TURN_SPEED: Single = 1.5;
  
  // Сохраненные начальные значения
  InitialYaw, InitialPitch: Single;
  InitialX, InitialY, InitialZ: Single;
  
  // Переменные для обработки клавиш
  LastFreecamToggle: Cardinal = 0;
  LastFreecamDisable: Cardinal = 0;
  FreecamKeyDelay: Cardinal = 1; // 200мс задержка между нажатиями
  MaxDistanceWritten: Boolean = False;  // ← ДОБАВИТЬ ЭТУ СТРОКУ
  
  // NOP патч
  OriginalBytes: array[0..4] of Byte;
  NopBytes: array[0..4] of Byte = ($90, $90, $90, $90, $90);

  // Переменные для системы день/ночи
  LastTimeCheck1: Cardinal = 0;
  TimeCheckInterval1: Cardinal = 7000; // проверка каждые 7 секунд
  CurrentTimeMode: Integer = -1; // -1 = не инициализировано, 0 = день, 1 = ночь
  DayNightInitialized: Boolean = False;
  HasDayNightFolders: Boolean = False;
  
  // ID текстур для дня и ночи
  DayCabTextureID: Cardinal = 0;
  DayPultTextureID: Cardinal = 0;
  Day254TextureID: Cardinal = 0;
  DayKlubTextureID: Cardinal = 0;
  
  NightCabTextureID: Cardinal = 0;
  NightPultTextureID: Cardinal = 0;
  Night254TextureID: Cardinal = 0;
  NightKlubTextureID: Cardinal = 0;

  CurrentIsNight: Boolean = False;


procedure ApplyMaxVisibleDistance; stdcall;
begin
  try
    PInteger(Pointer($91D4DD0))^ := Config_MaxVisibleDistance;
    AddToLogFile(EngineLog, 'MaxVisibleDistance установлена: ' + IntToStr(Config_MaxVisibleDistance));
  except
    on E: Exception do
      AddToLogFile(EngineLog, 'Ошибка установки MaxVisibleDistance: ' + E.Message);
  end;
end;

function GetLocomotiveFolder(locType: Integer): string;
begin
  case locType of
    812: Result := 'chs8';
    822: Result := 'chs7';
    882: Result := 'vl82';
    880: Result := 'vl80t';
    523: Result := 'chs4';
    524: Result := 'chs4kvr';
    621: Result := 'chs4t';
    2070: Result := 'tep70';
    2071: Result := 'tep70bs';
    1462: Result := 'm62';
    21014: Result := '2te10u';
    3154: Result := 'ed4m';
    3159: Result := 'ed9m';
    23152: Result := '2es5k';
    23142: Result := '2es4k';  // Предполагаю, что es4k = 2es4k
    343: Result := 'chs2k';
    31714: Result := 'ep1m';
    811: Result := 'vl11m';
    885: Result := 'vl85';
    201318: Result := 'tem18dm';
    else
      Result := 'chs7'; // по умолчанию
  end;
end;

function GetLocomotiveTypeFromSettings: Integer;
var
  f: TextFile;
  line, paramName, paramValue: string;
  equalPos: Integer;
  resultValue: Integer;
begin
  // Значение по умолчанию
  resultValue := 822;

  if FileExists('settings.ini') then
  begin
    try
      AssignFile(f, 'settings.ini');
      Reset(f);

      while not Eof(f) do
      begin
        ReadLn(f, line);
        line := Trim(line);

        // Пропускаем комментарии и пустые строки
        if (line = '') or (line[1] = '#') or (line[1] = ';') then
          Continue;

        equalPos := Pos('=', line);
        if equalPos > 0 then
        begin
          paramName := LowerCase(Trim(Copy(line, 1, equalPos - 1)));
          paramValue := Trim(Copy(line, equalPos + 1, Length(line)));

          if paramName = 'locomotivetype' then
          begin
            try
              resultValue := StrToInt(paramValue);
              Break;
            except
              // Ошибка преобразования — оставим значение по умолчанию
            end;
          end;
        end;
      end;

      CloseFile(f);
    except
      on E: Exception do
      begin
        try CloseFile(f); except end;
      end;
    end;
  end;

  Result := resultValue;
end;


procedure LoadSettingsAndCustomModels;
var
  f: TextFile;
  line: string;
  paramName, paramValue: string;
  equalPos: Integer;
  kolparaModelPath, kolparaTexturePath: string;
  klubModelPath, klubTexturePath: string;
  klubLsPath: string;  // Добавлено для klub_ls.dmd
  klubLsZPath, klubLsZhPath, klubLsKzhPath, klubLsKPath, klubLsBPath: string;
  skorPrivod1Path, skorPrivod2Path: string;
  // Пути к файлам пантографов
  pantoPodstavkaPath, pantoSkiPath, pantoLever2BotPath, pantoLever2TopPath, pantoLever1BotPath, pantoLever1TopPath: string;
  pantoTexturePath: string;  // Текстура пантографа
  
  // ===== ПЕРЕМЕННЫЕ ДЛЯ АЛЬТЕРНАТИВНЫХ МОДЕЛЕЙ =====
  strelkaSkorPath, strelkaSkorTimePath, pisec1Path, pisec2Path: string;
  lsModelPath, lsTexturePath: string; // Для fallback ls.dmd/ls.bmp
  
  directoryPath: string;
  modelAddr, textureAddr: Pointer;
  OldProtect: DWORD;
  locFolder: string;
  KolparaModelID, KolparaTextureID: Integer;
  SkorPrivod1ID, SkorPrivod2ID: Integer;
  KlubModelID, KlubTextureID: Cardinal;
  KlubLsID: Integer;  // Добавлено для klub_ls.dmd
  KlubLsZID, KlubLsZhID, KlubLsKzhID, KlubLsKID, KlubLsBID: Integer;
  // ID для моделей пантографов
  PantoPodstavkaID, PantoSkiID, PantoLever2BotID, PantoLever2TopID, PantoLever1BotID, PantoLever1TopID: Integer;
  PantoTextureID: Integer;  // ID текстуры пантографа
  
  // ===== ID ДЛЯ АЛЬТЕРНАТИВНЫХ МОДЕЛЕЙ =====
  StrelkaSkorID, StrelkaSkorTimeID, Pisec1ID, Pisec2ID: Integer;
  LsModelID: Integer;
  LsTextureID: Cardinal;
  
  hasCustomLoc: Boolean;
  baseStructAddr: Cardinal;
  
  // ===== НОВЫЕ ПЕРЕМЕННЫЕ ДЛЯ ЧТЕНИЯ ИЗ ПАМЯТИ =====
  klubFlag: Byte;  // Читаем из $7498A8
begin
  if SettingsLoaded then Exit;
  
  // Значения по умолчанию
  LocNum := '068';
  LocomotiveType := 822;
  
  // Читаем settings.ini
  if FileExists('settings.ini') then
  begin
    try
      AssignFile(f, 'settings.ini');
      Reset(f);
      
      while not Eof(f) do
      begin
        ReadLn(f, line);
        line := Trim(line);
        
        // Пропускаем пустые строки и комментарии
        if (line = '') or (line[1] = '#') or (line[1] = ';') then Continue;
        
        equalPos := Pos('=', line);
        if equalPos > 0 then
        begin
          paramName := LowerCase(Trim(Copy(line, 1, equalPos - 1)));
          paramValue := Trim(Copy(line, equalPos + 1, Length(line)));
          
          try
            if paramName = 'locnum' then
              LocNum := paramValue
            else if paramName = 'locomotivetype' then
              LocomotiveType := StrToInt(paramValue);
          except
            // Игнорируем ошибки преобразования
          end;
        end;
      end;

      CloseFile(f);
      AddToLogFile(EngineLog, 'settings.ini загружен - LocNum: ' + LocNum + ', LocomotiveType: ' + IntToStr(LocomotiveType));
      
    except
      on E: Exception do
      begin
        AddToLogFile(EngineLog, 'Ошибка чтения settings.ini: ' + E.Message);
        try
          CloseFile(f);
        except
        end;
      end;
    end;
  end
  else
  begin
    AddToLogFile(EngineLog, 'settings.ini не найден, используются значения по умолчанию - LocNum: ' + LocNum + ', LocomotiveType: ' + IntToStr(LocomotiveType));
  end;

  // Определяем папку локомотива по типу
  locFolder := GetLocomotiveFolder(LocomotiveType);
  AddToLogFile(EngineLog, 'Определена папка локомотива: ' + locFolder + ' для типа: ' + IntToStr(LocomotiveType));

  // Формируем путь к директории
  directoryPath := 'data\' + locFolder + '\' + LocNum + '\';
  AddToLogFile(EngineLog, 'Проверяем директорию: ' + directoryPath);
  
  // Проверяем существование директории loc
  hasCustomLoc := DirectoryExists(directoryPath + 'loc');
  
  if hasCustomLoc then
  begin
    AddToLogFile(EngineLog, 'Найдена папка loc в: ' + directoryPath);
    
    // ===== ЧИТАЕМ ФЛАГ ИЗ ПАМЯТИ =====
    try
      klubFlag := PByte(Pointer($7498A8))^;
      AddToLogFile(EngineLog, 'Флаг klub из памяти $7498A8: ' + IntToStr(klubFlag));
    except
      klubFlag := 1; // По умолчанию загружаем клуб
      AddToLogFile(EngineLog, 'Ошибка чтения флага klub, используется значение по умолчанию: 1');
    end;
    
    // ===== ЗАГРУЖАЕМ КОЛПАРА ИЗ КАСТОМНОЙ ПАПКИ =====
    // Пытаемся найти kolpara_el, если нет - ищем kolpara_tepl
    kolparaModelPath := directoryPath + 'loc\kolpara_el.dmd';
    kolparaTexturePath := directoryPath + 'loc\kolpara_el.bmp';
    
    if not (FileExists(kolparaModelPath) and FileExists(kolparaTexturePath)) then
    begin
      kolparaModelPath := directoryPath + 'loc\kolpara_tepl.dmd';
      kolparaTexturePath := directoryPath + 'loc\kolpara_tepl.bmp';
    end;
    
    // ===== ПРОВЕРЯЕМ ФЛАГ KLUB =====
    if klubFlag = 1 then
    begin
      AddToLogFile(EngineLog, 'Флаг klub=1: Загружаем модели клуба');
      
      // ===== ЗАГРУЖАЕМ КЛУБ ИЗ КАСТОМНОЙ ПАПКИ =====
      klubModelPath := directoryPath + 'loc\klub_bil_v.dmd';
      klubTexturePath := directoryPath + 'loc\klub_bil.bmp';
      
      AddToLogFile(EngineLog, 'Проверяем клуб модель: ' + klubModelPath);
      AddToLogFile(EngineLog, 'Проверяем клуб текстуру: ' + klubTexturePath);
      
      // Проверяем существование файлов
      if FileExists(klubModelPath) then
        AddToLogFile(EngineLog, 'Файл модели клуба найден: ' + klubModelPath)
      else
        AddToLogFile(EngineLog, 'ОШИБКА: Файл модели клуба НЕ найден: ' + klubModelPath);
        
      if FileExists(klubTexturePath) then
        AddToLogFile(EngineLog, 'Файл текстуры клуба найден: ' + klubTexturePath)
      else
        AddToLogFile(EngineLog, 'ОШИБКА: Файл текстуры клуба НЕ найден: ' + klubTexturePath);
      
      if FileExists(klubModelPath) and FileExists(klubTexturePath) then
      begin
        try
          // Загружаем модель и текстуру клуб
          AddToLogFile(EngineLog, 'Загружаем клуб модель: ' + klubModelPath);
          KlubModelID := LoadModel(klubModelPath, 0, False);
          AddToLogFile(EngineLog, 'Загружаем клуб текстуру: ' + klubTexturePath);
          KlubTextureID := LoadTextureFromFile(klubTexturePath, 0, -1);

          AddToLogFile(EngineLog, 'Клуб модель загружена, ID: ' + IntToStr(KlubModelID));
          AddToLogFile(EngineLog, 'Клуб текстура загружена, ID: ' + IntToStr(KlubTextureID));
          
          if (KlubModelID > 0) and (KlubTextureID > 0) then
          begin
            try
              // ===== ЗАПИСЫВАЕМ КЛУБ В ПАМЯТЬ =====
              // Записываем ID модели клуб по адресу Launcher.exe+8D10D70 [0x04]
              modelAddr := Pointer(PCardinal(Pointer($00400000 + $8D10D70))^ + $04);
              if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
              begin
                PWord(modelAddr)^ := Word(KlubModelID);
                VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
                AddToLogFile(EngineLog, 'ID клуб модели записан по адресу: ' + IntToHex(Cardinal(modelAddr), 8));
              end;
              
              // Записываем ID текстуры клуб по адресу 9110D60 [0x34]
              textureAddr := Pointer(PCardinal(Pointer($9110D60))^ + $34);
              if VirtualProtect(textureAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
              begin
                PWord(textureAddr)^ := Word(KlubTextureID);
                VirtualProtect(textureAddr, SizeOf(Word), OldProtect, OldProtect);
                AddToLogFile(EngineLog, 'ID клуб текстуры записан по адресу: ' + IntToHex(Cardinal(textureAddr), 8));
              end;
              
              CustomModelLoaded := True;
              AddToLogFile(EngineLog, 'Клуб модель и текстура успешно применены');
              
            except
              on E: Exception do
              begin
                AddToLogFile(EngineLog, 'Ошибка записи клуб в память: ' + E.Message);
              end;
            end;
          end
          else
          begin
            AddToLogFile(EngineLog, 'Ошибка загрузки клуб файлов - ModelID: ' + IntToStr(KlubModelID) + ', TextureID: ' + IntToStr(KlubTextureID));
          end;
          
        except
          on E: Exception do
          begin
            AddToLogFile(EngineLog, 'Ошибка загрузки клуб файлов: ' + E.Message);
          end;
        end;
      end
      else
      begin
        if not FileExists(klubModelPath) then
          AddToLogFile(EngineLog, 'Файл клуб модели не найден: ' + klubModelPath);
        if not FileExists(klubTexturePath) then
          AddToLogFile(EngineLog, 'Файл клуб текстуры не найден: ' + klubTexturePath);
      end;
    end
    else
    begin
      AddToLogFile(EngineLog, 'Флаг klub=0: Загружаем альтернативные модели');
      
      // ===== ЗАГРУЖАЕМ АЛЬТЕРНАТИВНЫЕ МОДЕЛИ =====
      strelkaSkorPath := directoryPath + 'loc\strelka_skor.dmd';
      strelkaSkorTimePath := directoryPath + 'loc\strelka_skor_time.dmd';
      pisec1Path := directoryPath + 'loc\pisec1.dmd';
      pisec2Path := directoryPath + 'loc\pisec2.dmd';
      lsModelPath := directoryPath + 'loc\ls.dmd';
      lsTexturePath := directoryPath + 'loc\ls.bmp';
      
      skorPrivod1Path := directoryPath + 'loc\skor_privod1.dmd';
      skorPrivod2Path := directoryPath + 'loc\skor_privod2.dmd';

      // strelka_skor.dmd - Launcher.exe+8D10D70 [0x06]
      if FileExists(strelkaSkorPath) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем strelka_skor: ' + strelkaSkorPath);
          StrelkaSkorID := LoadModel(strelkaSkorPath, 0, False);
          
          if StrelkaSkorID > 0 then
          begin
            modelAddr := Pointer(PCardinal(Pointer($00400000 + $8D10D70))^ + $06);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(StrelkaSkorID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              AddToLogFile(EngineLog, 'strelka_skor загружена, ID: ' + IntToStr(StrelkaSkorID));
            end;
          end;
        except
          AddToLogFile(EngineLog, 'Ошибка загрузки strelka_skor');
        end;
      end;
      
      // strelka_skor_time.dmd - Launcher.exe+8D10D70 [0x08]
      if FileExists(strelkaSkorTimePath) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем strelka_skor_time: ' + strelkaSkorTimePath);
          StrelkaSkorTimeID := LoadModel(strelkaSkorTimePath, 0, False);
          
          if StrelkaSkorTimeID > 0 then
          begin
            modelAddr := Pointer(PCardinal(Pointer($00400000 + $8D10D70))^ + $08);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(StrelkaSkorTimeID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              AddToLogFile(EngineLog, 'strelka_skor_time загружена, ID: ' + IntToStr(StrelkaSkorTimeID));
            end;
          end;
        except
          AddToLogFile(EngineLog, 'Ошибка загрузки strelka_skor_time');
        end;
      end;

      
      // pisec1.dmd - Launcher.exe+8D10D70 [0xA] 
      if FileExists(pisec1Path) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем pisec1: ' + pisec1Path);
          Pisec1ID := LoadModel(pisec1Path, 0, False);
          
          if Pisec1ID > 0 then
          begin
            AddToLogFile(EngineLog, 'pisec1 загружена, ID: ' + IntToStr(Pisec1ID));
            
            // ИСПРАВЛЕНО: используем правильное выравнивание и размер
            modelAddr := Pointer(PCardinal(Pointer($00400000 + $8D10D70))^ + $0A);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              // БЕЗОПАСНАЯ ЗАПИСЬ: сначала читаем текущее значение
              PWord(modelAddr)^ := Word(Pisec1ID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              
              // ПРОВЕРКА ЗАПИСИ
              if PWord(modelAddr)^ = Word(Pisec1ID) then
                AddToLogFile(EngineLog, Format('pisec1 записан успешно: %d по адресу %s', 
                  [Pisec1ID, IntToHex(Cardinal(modelAddr), 8)]))
              else
                AddToLogFile(EngineLog, Format('ОШИБКА записи pisec1: ожидали %d, получили %d', 
                  [Pisec1ID, PWord(modelAddr)^]));
            end
            else
            begin
              AddToLogFile(EngineLog, 'ОШИБКА: не удалось изменить защиту памяти для pisec1');
            end;
          end
          else
          begin
            AddToLogFile(EngineLog, 'ОШИБКА: LoadModel вернул 0 для pisec1');
          end;
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'ИСКЛЮЧЕНИЕ при загрузке pisec1: ' + E.Message);
        end;
      end
      else
      begin
        AddToLogFile(EngineLog, 'pisec1.dmd не найден: ' + pisec1Path);
      end;
      
      // pisec2.dmd - Launcher.exe+8D10D70 [0xC] <- ИСПРАВЛЕНО СМЕЩЕНИЕ!
      if FileExists(pisec2Path) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем pisec2: ' + pisec2Path);
          Pisec2ID := LoadModel(pisec2Path, 0, False);
          
          if Pisec2ID > 0 then
          begin
            AddToLogFile(EngineLog, 'pisec2 загружена, ID: ' + IntToStr(Pisec2ID));
            
            // ИСПРАВЛЕНО: правильное смещение +$0C вместо +$0B
            modelAddr := Pointer(PCardinal(Pointer($00400000 + $8D10D70))^ + $0C);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(Pisec2ID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              
              // ПРОВЕРКА ЗАПИСИ
              if PWord(modelAddr)^ = Word(Pisec2ID) then
                AddToLogFile(EngineLog, Format('pisec2 записан успешно: %d по адресу %s', 
                  [Pisec2ID, IntToHex(Cardinal(modelAddr), 8)]))
              else
                AddToLogFile(EngineLog, Format('ОШИБКА записи pisec2: ожидали %d, получили %d', 
                  [Pisec2ID, PWord(modelAddr)^]));
            end
            else
            begin
              AddToLogFile(EngineLog, 'ОШИБКА: не удалось изменить защиту памяти для pisec2');
            end;
          end
          else
          begin
            AddToLogFile(EngineLog, 'ОШИБКА: LoadModel вернул 0 для pisec2');
          end;
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'ИСКЛЮЧЕНИЕ при загрузке pisec2: ' + E.Message);
        end;
      end
      else
      begin
        AddToLogFile(EngineLog, 'pisec2.dmd не найден: ' + pisec2Path);
      end;

      // skor_privod1.dmd - Launcher.exe+8D10D70 [0xE]
      if FileExists(skorPrivod1Path) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем skor_privod1: ' + skorPrivod1Path);
          SkorPrivod1ID := LoadModel(skorPrivod1Path, 0, False);
          
          if SkorPrivod1ID > 0 then
          begin
            AddToLogFile(EngineLog, 'skor_privod1 загружена, ID: ' + IntToStr(SkorPrivod1ID));
            
            modelAddr := Pointer(PCardinal(Pointer($00400000 + $8D10D70))^ + $0E);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(SkorPrivod1ID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              
              if PWord(modelAddr)^ = Word(SkorPrivod1ID) then
                AddToLogFile(EngineLog, Format('skor_privod1 записан успешно: %d по адресу %s', 
                  [SkorPrivod1ID, IntToHex(Cardinal(modelAddr), 8)]))
              else
                AddToLogFile(EngineLog, Format('ОШИБКА записи skor_privod1: ожидали %d, получили %d', 
                  [SkorPrivod1ID, PWord(modelAddr)^]));
            end
            else
            begin
              AddToLogFile(EngineLog, 'ОШИБКА: не удалось изменить защиту памяти для skor_privod1');
            end;
          end
          else
          begin
            AddToLogFile(EngineLog, 'ОШИБКА: LoadModel вернул 0 для skor_privod1');
          end;
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'ИСКЛЮЧЕНИЕ при загрузке skor_privod1: ' + E.Message);
        end;
      end
      else
      begin
        AddToLogFile(EngineLog, 'skor_privod1.dmd не найден: ' + skorPrivod1Path);
      end;

      if FileExists(skorPrivod2Path) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем skor_privod2: ' + skorPrivod2Path);
          SkorPrivod2ID := LoadModel(skorPrivod2Path, 0, False);
          
          if SkorPrivod2ID > 0 then
          begin
            AddToLogFile(EngineLog, 'skor_privod2 загружена, ID: ' + IntToStr(SkorPrivod2ID));
            
            modelAddr := Pointer(PCardinal(Pointer($00400000 + $8D10D70))^ + $10);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(SkorPrivod2ID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              
              if PWord(modelAddr)^ = Word(SkorPrivod2ID) then
                AddToLogFile(EngineLog, Format('skor_privod2 записан успешно: %d по адресу %s', 
                  [SkorPrivod2ID, IntToHex(Cardinal(modelAddr), 8)]))
              else
                AddToLogFile(EngineLog, Format('ОШИБКА записи skor_privod2: ожидали %d, получили %d', 
                  [SkorPrivod2ID, PWord(modelAddr)^]));
            end
            else
            begin
              AddToLogFile(EngineLog, 'ОШИБКА: не удалось изменить защиту памяти для skor_privod2');
            end;
          end
          else
          begin
            AddToLogFile(EngineLog, 'ОШИБКА: LoadModel вернул 0 для skor_privod2');
          end;
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'ИСКЛЮЧЕНИЕ при загрузке skor_privod2: ' + E.Message);
        end;
      end
      else
      begin
        AddToLogFile(EngineLog, 'skor_privod2.dmd не найден: ' + skorPrivod2Path);
      end;

      // ls.dmd и ls.bmp
      if FileExists(lsModelPath) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем ls модель: ' + lsModelPath);
          LsModelID := LoadModel(lsModelPath, 0, False);
          AddToLogFile(EngineLog, 'LS модель загружена, ID: ' + IntToStr(LsModelID));

          if LsModelID > 0 then
          begin
            // Записываем ID модели ls по адресу Launcher.exe+8D10D70 [+$12]
            modelAddr := Pointer(PCardinal(Pointer($00400000 + $8D10D70))^ + $12);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(LsModelID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              AddToLogFile(EngineLog, 'ID ls модели записан по адресу: ' + IntToHex(Cardinal(modelAddr), 8));
            end;

            // Если есть ls.bmp, загружаем и его
            if FileExists(lsTexturePath) then
            begin
              try
                LsTextureID := LoadTextureFromFile(lsTexturePath, 0, -1);
                if LsTextureID > 0 then
                begin
                  AddToLogFile(EngineLog, 'LS текстура загружена, ID: ' + IntToStr(LsTextureID));
                  
                  // Записываем ls.bmp по адресу 9110D60 + $36
                  textureAddr := Pointer(PCardinal(Pointer($9110D60))^ + $36);
                  if VirtualProtect(textureAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
                  begin
                    PWord(textureAddr)^ := Word(LsTextureID);
                    VirtualProtect(textureAddr, SizeOf(Word), OldProtect, OldProtect);
                    AddToLogFile(EngineLog, 'ID ls текстуры записан по адресу: ' + IntToHex(Cardinal(textureAddr), 8));
                  end;
                end;
              except
                AddToLogFile(EngineLog, 'Ошибка загрузки ls текстуры');
              end;
            end
            else
            begin
              AddToLogFile(EngineLog, 'ls.bmp не найден: ' + lsTexturePath);
            end;

            CustomModelLoaded := True;
            AddToLogFile(EngineLog, 'LS модель успешно применена');
          end;
          
        except
          on E: Exception do
          begin
            AddToLogFile(EngineLog, 'Ошибка загрузки ls: ' + E.Message);
          end;
        end;
      end
      else
      begin
        AddToLogFile(EngineLog, 'ls.dmd не найден: ' + lsModelPath);
      end;
    end;
    
    // ===== ЗАГРУЖАЕМ KLUB_LS С FALLBACK =====
    klubLsPath := directoryPath + 'loc\klub_ls.dmd';
    AddToLogFile(EngineLog, 'Проверяем klub_ls модель: ' + klubLsPath);
    
    if FileExists(klubLsPath) then
    begin
      try
        AddToLogFile(EngineLog, 'Загружаем klub_ls модель: ' + klubLsPath);
        KlubLsID := LoadModel(klubLsPath, 0, False);
        AddToLogFile(EngineLog, 'Klub_LS модель загружена, ID: ' + IntToStr(KlubLsID));

        if KlubLsID > 0 then
        begin
          // Записываем ID модели klub_ls по адресу Launcher.exe+8D10D70 [+$12]
          modelAddr := Pointer(PCardinal(Pointer($00400000 + $8D10D70))^ + $12);
          if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
          begin
            PWord(modelAddr)^ := Word(KlubLsID);
            VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
            AddToLogFile(EngineLog, 'ID klub_ls модели записан по адресу: ' + IntToHex(Cardinal(modelAddr), 8));
          end;

          CustomModelLoaded := True;
          AddToLogFile(EngineLog, 'Klub_LS модель успешно применена');
        end;
        
      except
        on E: Exception do
        begin
          AddToLogFile(EngineLog, 'Ошибка загрузки klub_ls: ' + E.Message);
        end;
      end;
    end
    else
    begin
      AddToLogFile(EngineLog, 'klub_ls.dmd не найден: ' + klubLsPath);
    end;
    
    // ===== ЗАГРУЖАЕМ КОЛПАРА =====
    // Определяем какую версию колпара будем использовать
    AddToLogFile(EngineLog, 'Проверяем колпара модель: ' + kolparaModelPath);
    AddToLogFile(EngineLog, 'Проверяем колпара текстуру: ' + kolparaTexturePath);

    // Проверяем существование файлов
    if FileExists(kolparaModelPath) then
      AddToLogFile(EngineLog, 'Файл модели колпара найден: ' + kolparaModelPath)
    else
      AddToLogFile(EngineLog, 'ОШИБКА: Файл модели колпара НЕ найден: ' + kolparaModelPath);
      
    if FileExists(kolparaTexturePath) then
      AddToLogFile(EngineLog, 'Файл текстуры колпара найден: ' + kolparaTexturePath)
    else
      AddToLogFile(EngineLog, 'ОШИБКА: Файл текстуры колпара НЕ найден: ' + kolparaTexturePath);

    if FileExists(kolparaModelPath) and FileExists(kolparaTexturePath) then
    begin
      try
        // Загружаем модель и текстуру колпара
        KolparaModelID := LoadModel(kolparaModelPath, 0, False);
        KolparaTextureID := LoadTextureFromFile(kolparaTexturePath, 0, -1);

        if (KolparaModelID > 0) and (KolparaTextureID > 0) then
        begin
          // Получаем базовый адрес структуры
          baseStructAddr := PCardinal(Pointer($00400000 + $8D10D70))^;

          // Записываем ID модели по адресу baseStructAddr + $34
          modelAddr := Pointer(baseStructAddr + $34);
          if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
          begin
            PWord(modelAddr)^ := Word(KolparaModelID);  // ← Word вместо Integer
            VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
          end;

          // Записываем ID текстуры по адресу 0x9110D60 + $3E
          textureAddr := Pointer(PCardinal(Pointer($9110D60))^ + $3E);
          if VirtualProtect(textureAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
          begin
            PWord(textureAddr)^ := Word(KolparaTextureID);  // ← Word вместо Cardinal
            VirtualProtect(textureAddr, SizeOf(Word), OldProtect, OldProtect);
          end;

          CustomModelLoaded := True;
        end;

      except
        on E: Exception do
        begin
          //AddToLogFile(EngineLog, 'Ошибка загрузки колпара: ' + E.Message);
        end;
      end;
    end
    else
    begin
      if not FileExists(kolparaModelPath) then
        //AddToLogFile(EngineLog, 'Файл колпара модели не найден: ' + kolparaModelPath);
      if not FileExists(kolparaTexturePath) then
        //AddToLogFile(EngineLog, 'Файл колпара текстуры не найден: ' + kolparaTexturePath);
    end;
    
    // ===== ЗАГРУЖАЕМ ПАНТОГРАФЫ ИЗ КАСТОМНОЙ ПАПКИ =====
    AddToLogFile(EngineLog, 'Загружаем пантографы...');
    
    // Всегда используем tp_podstavka.dmd вместо l13u_podstavka-0.dmd
    pantoPodstavkaPath := directoryPath + 'loc\tp_podstavka.dmd';
    pantoSkiPath := directoryPath + 'loc\tp_ski.dmd';
    pantoLever2BotPath := directoryPath + 'loc\l13u_lever1bot.dmd';
    pantoLever2TopPath := directoryPath + 'loc\l13u_lever1top.dmd';
    pantoLever1BotPath := directoryPath + 'loc\l13u_lever2bot.dmd';
    pantoLever1TopPath := directoryPath + 'loc\l13u_lever2top.dmd';
    pantoTexturePath := directoryPath + 'loc\2sls1.bmp';
    
    // Если l13u файлы не найдены, ищем tp альтернативы
    if not FileExists(pantoLever2BotPath) then
      pantoLever2BotPath := directoryPath + 'loc\tp_lever1bot.dmd';
    if not FileExists(pantoLever2TopPath) then
      pantoLever2TopPath := directoryPath + 'loc\tp_lever1top.dmd';
    if not FileExists(pantoLever1BotPath) then
      pantoLever1BotPath := directoryPath + 'loc\tp_lever2bot.dmd';
    if not FileExists(pantoLever1TopPath) then
      pantoLever1TopPath := directoryPath + 'loc\tp_lever2top.dmd';
    
    // Проверяем существование файлов пантографов
    AddToLogFile(EngineLog, 'Проверяем файлы пантографов:');
    AddToLogFile(EngineLog, 'Подставка: ' + pantoPodstavkaPath + ' - ' + BoolToStr(FileExists(pantoPodstavkaPath), True));
    AddToLogFile(EngineLog, 'Лыжи: ' + pantoSkiPath + ' - ' + BoolToStr(FileExists(pantoSkiPath), True));
    AddToLogFile(EngineLog, 'Рычаг 2 низ: ' + pantoLever2BotPath + ' - ' + BoolToStr(FileExists(pantoLever2BotPath), True));
    AddToLogFile(EngineLog, 'Рычаг 2 верх: ' + pantoLever2TopPath + ' - ' + BoolToStr(FileExists(pantoLever2TopPath), True));
    AddToLogFile(EngineLog, 'Рычаг 1 низ: ' + pantoLever1BotPath + ' - ' + BoolToStr(FileExists(pantoLever1BotPath), True));
    AddToLogFile(EngineLog, 'Рычаг 1 верх: ' + pantoLever1TopPath + ' - ' + BoolToStr(FileExists(pantoLever1TopPath), True));
    AddToLogFile(EngineLog, 'Текстура: ' + pantoTexturePath + ' - ' + BoolToStr(FileExists(pantoTexturePath), True));
    
    // Загружаем текстуру пантографа если есть
    if FileExists(pantoTexturePath) then
    begin
      try
        AddToLogFile(EngineLog, 'Загружаем текстуру пантографа: ' + pantoTexturePath);
        PantoTextureID := LoadTextureFromFile(pantoTexturePath, 0, -1);
        AddToLogFile(EngineLog, 'Текстура пантографа загружена, ID: ' + IntToStr(PantoTextureID));
        
        if PantoTextureID > 0 then
        begin
          textureAddr := Pointer(PCardinal(Pointer($9110D60))^ + $3C);
          if VirtualProtect(textureAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
          begin
            PWord(textureAddr)^ := Word(PantoTextureID);
            VirtualProtect(textureAddr, SizeOf(Word), OldProtect, OldProtect);
            AddToLogFile(EngineLog, 'Текстура пантографа записана по адресу: ' + IntToHex(Cardinal(textureAddr), 8));
          end;
        end;
      except
        on E: Exception do
          AddToLogFile(EngineLog, 'Ошибка загрузки текстуры пантографа: ' + E.Message);
      end;
    end
    else
    begin
      AddToLogFile(EngineLog, 'Файл текстуры пантографа не найден: ' + pantoTexturePath);
    end;

    try
      // Получаем базовый адрес структуры
      baseStructAddr := PCardinal(Pointer($00400000 + $8D10D70))^;

      // tp_podstavka - смещение +$28
      if FileExists(pantoPodstavkaPath) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем подставку пантографа: ' + pantoPodstavkaPath);
          PantoPodstavkaID := LoadModel(pantoPodstavkaPath, 0, False);
          AddToLogFile(EngineLog, 'Подставка пантографа загружена, ID: ' + IntToStr(PantoPodstavkaID));

          if PantoPodstavkaID > 0 then
          begin
            modelAddr := Pointer(baseStructAddr + $28);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(PantoPodstavkaID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              AddToLogFile(EngineLog, 'Подставка пантографа записана по адресу: ' + IntToHex(Cardinal(modelAddr), 8));
            end;
          end;
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'Ошибка загрузки подставки пантографа: ' + E.Message);
        end;
      end
      else
      begin
        AddToLogFile(EngineLog, 'Файл подставки пантографа не найден: ' + pantoPodstavkaPath);
      end;
      
      // tp_ski-0 - смещение +$2A
      if FileExists(pantoSkiPath) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем лыжи пантографа: ' + pantoSkiPath);
          PantoSkiID := LoadModel(pantoSkiPath, 0, False);
          AddToLogFile(EngineLog, 'Лыжи пантографа загружены, ID: ' + IntToStr(PantoSkiID));
          
          if PantoSkiID > 0 then
          begin
            modelAddr := Pointer(baseStructAddr + $2A);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(PantoSkiID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              AddToLogFile(EngineLog, 'Лыжи пантографа записаны по адресу: ' + IntToHex(Cardinal(modelAddr), 8));
            end;
          end;
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'Ошибка загрузки лыж пантографа: ' + E.Message);
        end;
      end
      else
      begin
        AddToLogFile(EngineLog, 'Файл лыж пантографа не найден: ' + pantoSkiPath);
      end;

      // l13u_lever2bot - смещение +$2C
      if FileExists(pantoLever2BotPath) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем нижний рычаг 2 пантографа: ' + pantoLever2BotPath);
          PantoLever2BotID := LoadModel(pantoLever2BotPath, 0, False);
          AddToLogFile(EngineLog, 'Нижний рычаг 2 пантографа загружен, ID: ' + IntToStr(PantoLever2BotID));
          
          if PantoLever2BotID > 0 then
          begin
            modelAddr := Pointer(baseStructAddr + $2C);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(PantoLever2BotID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              AddToLogFile(EngineLog, 'Нижний рычаг 2 пантографа записан по адресу: ' + IntToHex(Cardinal(modelAddr), 8));
            end;
          end;
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'Ошибка загрузки нижнего рычага 2 пантографа: ' + E.Message);
        end;
      end
      else
      begin
        AddToLogFile(EngineLog, 'Файл нижнего рычага 2 пантографа не найден: ' + pantoLever2BotPath);
      end;
      
      // l13u_lever2top - смещение +$2E
      if FileExists(pantoLever2TopPath) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем верхний рычаг 2 пантографа: ' + pantoLever2TopPath);
          PantoLever2TopID := LoadModel(pantoLever2TopPath, 0, False);
          AddToLogFile(EngineLog, 'Верхний рычаг 2 пантографа загружен, ID: ' + IntToStr(PantoLever2TopID));
          
          if PantoLever2TopID > 0 then
          begin
            modelAddr := Pointer(baseStructAddr + $2E);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(PantoLever2TopID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              AddToLogFile(EngineLog, 'Верхний рычаг 2 пантографа записан по адресу: ' + IntToHex(Cardinal(modelAddr), 8));
            end;
          end;
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'Ошибка загрузки верхнего рычага 2 пантографа: ' + E.Message);
        end;
      end
      else
      begin
        AddToLogFile(EngineLog, 'Файл верхнего рычага 2 пантографа не найден: ' + pantoLever2TopPath);
      end;
      
      // l13u_lever1bot - смещение +$30
      if FileExists(pantoLever1BotPath) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем нижний рычаг 1 пантографа: ' + pantoLever1BotPath);
          PantoLever1BotID := LoadModel(pantoLever1BotPath, 0, False);
          AddToLogFile(EngineLog, 'Нижний рычаг 1 пантографа загружен, ID: ' + IntToStr(PantoLever1BotID));
          
          if PantoLever1BotID > 0 then
          begin
            modelAddr := Pointer(baseStructAddr + $30);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(PantoLever1BotID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              AddToLogFile(EngineLog, 'Нижний рычаг 1 пантографа записан по адресу: ' + IntToHex(Cardinal(modelAddr), 8));
            end;
          end;
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'Ошибка загрузки нижнего рычага 1 пантографа: ' + E.Message);
        end;
      end
      else
      begin
        AddToLogFile(EngineLog, 'Файл нижнего рычага 1 пантографа не найден: ' + pantoLever1BotPath);
      end;

      // l13u_lever1top - смещение +$32
      if FileExists(pantoLever1TopPath) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем верхний рычаг 1 пантографа: ' + pantoLever1TopPath);
          PantoLever1TopID := LoadModel(pantoLever1TopPath, 0, False);
          AddToLogFile(EngineLog, 'Верхний рычаг 1 пантографа загружен, ID: ' + IntToStr(PantoLever1TopID));

          if PantoLever1TopID > 0 then
          begin
            modelAddr := Pointer(baseStructAddr + $32);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(PantoLever1TopID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              AddToLogFile(EngineLog, 'Верхний рычаг 1 пантографа записан по адресу: ' + IntToHex(Cardinal(modelAddr), 8));
            end;
          end;
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'Ошибка загрузки верхнего рычага 1 пантографа: ' + E.Message);
        end;
      end
      else
      begin
        AddToLogFile(EngineLog, 'Файл верхнего рычага 1 пантографа не найден: ' + pantoLever1TopPath);
      end;
      
    except
      on E: Exception do
        //AddToLogFile(EngineLog, 'Критическая ошибка при загрузке пантографов: ' + E.Message);
    end;
    
    // ===== ЗАГРУЖАЕМ КЛУБ ЛС МОДЕЛИ - ПРАВИЛЬНЫЕ СМЕЩЕНИЯ =====
    AddToLogFile(EngineLog, 'Загружаем КЛУБ ЛС модели...');
    
    klubLsZPath := directoryPath + 'loc\klub_ls_z.dmd';      // Зеленый
    klubLsZhPath := directoryPath + 'loc\klub_ls_zh.dmd';    // Желтый
    klubLsKzhPath := directoryPath + 'loc\klub_ls_kzh.dmd';  // Красно-желтый
    klubLsKPath := directoryPath + 'loc\klub_ls_k.dmd';      // Красный
    klubLsBPath := directoryPath + 'loc\klub_ls_b.dmd';      // Белый
    
    try
      // Получаем базовый адрес структуры один раз
      baseStructAddr := PCardinal(Pointer($00400000 + $8D10D70))^;
      AddToLogFile(EngineLog, 'Базовый адрес структуры: ' + IntToHex(baseStructAddr, 8));

      // ВАЖНО: НЕ перезаписываем основной клуб по +$04!
      // Основной клуб уже загружен выше по +$04

      // Проверяем файлы светофоров
      AddToLogFile(EngineLog, 'Проверяем файлы светофоров:');
      AddToLogFile(EngineLog, 'Белый: ' + klubLsBPath + ' - ' + BoolToStr(FileExists(klubLsBPath), True));
      AddToLogFile(EngineLog, 'Красный: ' + klubLsKPath + ' - ' + BoolToStr(FileExists(klubLsKPath), True));
      AddToLogFile(EngineLog, 'Красно-желтый: ' + klubLsKzhPath + ' - ' + BoolToStr(FileExists(klubLsKzhPath), True));
      AddToLogFile(EngineLog, 'Желтый: ' + klubLsZhPath + ' - ' + BoolToStr(FileExists(klubLsZhPath), True));
      AddToLogFile(EngineLog, 'Зеленый: ' + klubLsZPath + ' - ' + BoolToStr(FileExists(klubLsZPath), True));

      // Белый светофор - смещение +$14
      if FileExists(klubLsBPath) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем белый светофор: ' + klubLsBPath);
          KlubLsBID := LoadModel(klubLsBPath, 0, False);
          AddToLogFile(EngineLog, 'Белый светофор загружен, ID: ' + IntToStr(KlubLsBID));
          
          if KlubLsBID > 0 then
          begin
            modelAddr := Pointer(baseStructAddr + $14);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(KlubLsBID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              AddToLogFile(EngineLog, Format('КЛУБ ЛС Белый загружен, ID: %d, адрес: %s',
                [KlubLsBID, IntToHex(Cardinal(modelAddr), 8)]));
            end;
          end;
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'Ошибка загрузки КЛУБ ЛС Белый: ' + E.Message);
        end;
      end;
      
      // Красный светофор - смещение +$16
      if FileExists(klubLsKPath) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем красный светофор: ' + klubLsKPath);
          KlubLsKID := LoadModel(klubLsKPath, 0, False);
          AddToLogFile(EngineLog, 'Красный светофор загружен, ID: ' + IntToStr(KlubLsKID));
          
          if KlubLsKID > 0 then
          begin
            modelAddr := Pointer(baseStructAddr + $16);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(KlubLsKID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              AddToLogFile(EngineLog, Format('КЛУБ ЛС Красный загружен, ID: %d, адрес: %s',
                [KlubLsKID, IntToHex(Cardinal(modelAddr), 8)]));
            end;
          end;
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'Ошибка загрузки КЛУБ ЛС Красный: ' + E.Message);
        end;
      end;
      
      // Красно-желтый светофор - смещение +$18
      if FileExists(klubLsKzhPath) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем красно-желтый светофор: ' + klubLsKzhPath);
          KlubLsKzhID := LoadModel(klubLsKzhPath, 0, False);
          AddToLogFile(EngineLog, 'Красно-желтый светофор загружен, ID: ' + IntToStr(KlubLsKzhID));
          
          if KlubLsKzhID > 0 then
          begin
            modelAddr := Pointer(baseStructAddr + $18);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(KlubLsKzhID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              AddToLogFile(EngineLog, Format('КЛУБ ЛС Красно-желтый загружен, ID: %d, адрес: %s',
                [KlubLsKzhID, IntToHex(Cardinal(modelAddr), 8)]));
            end;
          end;
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'Ошибка загрузки КЛУБ ЛС Красно-желтый: ' + E.Message);
        end;
      end;
      
      // Желтый светофор - смещение +$1A
      if FileExists(klubLsZhPath) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем желтый светофор: ' + klubLsZhPath);
          KlubLsZhID := LoadModel(klubLsZhPath, 0, False);
          AddToLogFile(EngineLog, 'Желтый светофор загружен, ID: ' + IntToStr(KlubLsZhID));
          
          if KlubLsZhID > 0 then
          begin
            modelAddr := Pointer(baseStructAddr + $1A);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(KlubLsZhID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              AddToLogFile(EngineLog, Format('КЛУБ ЛС Желтый загружен, ID: %d, адрес: %s',
                [KlubLsZhID, IntToHex(Cardinal(modelAddr), 8)]));
            end;
          end;
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'Ошибка загрузки КЛУБ ЛС Желтый: ' + E.Message);
        end;
      end;
      
      // Зеленый светофор - смещение +$1C
      if FileExists(klubLsZPath) then
      begin
        try
          AddToLogFile(EngineLog, 'Загружаем зеленый светофор: ' + klubLsZPath);
          KlubLsZID := LoadModel(klubLsZPath, 0, False);
          AddToLogFile(EngineLog, 'Зеленый светофор загружен, ID: ' + IntToStr(KlubLsZID));

          if KlubLsZID > 0 then
          begin
            modelAddr := Pointer(baseStructAddr + $1C);
            if VirtualProtect(modelAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
            begin
              PWord(modelAddr)^ := Word(KlubLsZID);
              VirtualProtect(modelAddr, SizeOf(Word), OldProtect, OldProtect);
              AddToLogFile(EngineLog, Format('КЛУБ ЛС Зеленый загружен, ID: %d, адрес: %s',
                [KlubLsZID, IntToHex(Cardinal(modelAddr), 8)]));
            end;
          end;
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'Ошибка загрузки КЛУБ ЛС Зеленый: ' + E.Message);
        end;
      end;

      // ОТЛАДОЧНОЕ ЧТЕНИЕ - проверяем что записалось
      AddToLogFile(EngineLog, '=== ПРОВЕРКА ЗАПИСАННЫХ ЗНАЧЕНИЙ ===');
      AddToLogFile(EngineLog, 'Проверка всех загруженных моделей:');
      try
        AddToLogFile(EngineLog, Format('Колпара (+$34): %d', [PWord(Pointer(baseStructAddr + $34))^]));
        if klubFlag = 1 then
          AddToLogFile(EngineLog, Format('Основной клуб (+$04): %d', [PWord(Pointer(baseStructAddr + $04))^]))
        else
        begin
          AddToLogFile(EngineLog, Format('strelka_skor (+$06): %d', [PWord(Pointer(baseStructAddr + $06))^]));
          AddToLogFile(EngineLog, Format('strelka_skor_time (+$08): %d', [PWord(Pointer(baseStructAddr + $08))^]));
          AddToLogFile(EngineLog, Format('pisec1 (+$0A): %d', [PWord(Pointer(baseStructAddr + $0A))^]));
          AddToLogFile(EngineLog, Format('pisec2 (+$0B): %d', [PWord(Pointer(baseStructAddr + $0B))^]));
        end;
        AddToLogFile(EngineLog, Format('Klub_LS (+$12): %d', [PWord(Pointer(baseStructAddr + $12))^]));
        AddToLogFile(EngineLog, Format('Белый (+$14): %d', [PWord(Pointer(baseStructAddr + $14))^]));
        AddToLogFile(EngineLog, Format('Красный (+$16): %d', [PWord(Pointer(baseStructAddr + $16))^]));
        AddToLogFile(EngineLog, Format('Красно-желтый (+$18): %d', [PWord(Pointer(baseStructAddr + $18))^]));
        AddToLogFile(EngineLog, Format('Желтый (+$1A): %d', [PWord(Pointer(baseStructAddr + $1A))^]));
        AddToLogFile(EngineLog, Format('Зеленый (+$1C): %d', [PWord(Pointer(baseStructAddr + $1C))^]));
        AddToLogFile(EngineLog, Format('Подставка пантографа (+$28): %d', [PWord(Pointer(baseStructAddr + $28))^]));
        AddToLogFile(EngineLog, Format('Лыжи пантографа (+$2A): %d', [PWord(Pointer(baseStructAddr + $2A))^]));
        AddToLogFile(EngineLog, Format('Нижний рычаг 2 (+$2C): %d', [PWord(Pointer(baseStructAddr + $2C))^]));
        AddToLogFile(EngineLog, Format('Верхний рычаг 2 (+$2E): %d', [PWord(Pointer(baseStructAddr + $2E))^]));
        AddToLogFile(EngineLog, Format('Нижний рычаг 1 (+$30): %d', [PWord(Pointer(baseStructAddr + $30))^]));
        AddToLogFile(EngineLog, Format('Верхний рычаг 1 (+$32): %d', [PWord(Pointer(baseStructAddr + $32))^]));
        AddToLogFile(EngineLog, Format('Текстура пантографа (9110D60+$3C): %d', [PWord(Pointer(PCardinal(Pointer($9110D60))^ + $3C))^]));
        if klubFlag = 0 then
          AddToLogFile(EngineLog, Format('LS текстура (9110D60+$36): %d', [PWord(Pointer(PCardinal(Pointer($9110D60))^ + $36))^]));
      except
        AddToLogFile(EngineLog, 'Ошибка чтения записанных значений');
      end;
      
    except
      on E: Exception do
        AddToLogFile(EngineLog, 'Критическая ошибка при загрузке КЛУБ ЛС: ' + E.Message);
    end;
  end
  else
  begin
    AddToLogFile(EngineLog, 'Папка loc не найдена, пропускаем загрузку кастомных моделей');
  end;
  
  SettingsLoaded := True;
end;


function GetLocoPatchOffset(locType: Integer): Cardinal;
begin
  case locType of
    812: Result := $7245D8;   // ЧС8
    822: Result := $7245EF;   // ЧС7 - работает
    882: Result := $724606;   // ВЛ82М
    880: Result := $72461D;   // ВЛ80Т
    621: Result := $724634;   // ЧС4Т
    523: Result := $724643;   // ЧС4
    524: Result := $724662;   // ЧС4КВР
    2070: Result := $724679;  // ТЭП70
    2071: Result := $724690;  // ТЭП70БС
    1462: Result := $7246A7;  // М62
    21014: Result := $7246BE; // 2ТЭ10У
    3154: Result := $7246D5;  // ЭД4М
    3159: Result := $7246EC;  // ЭД9М
    23152: Result := $724703; // 2ЭС5К
    23142: Result := $724717; // 2ЭС4К
    343: Result := $72472B;   // ЧС2К
    31714: Result := $72473F; // ЭП1М
    811: Result := $724753;   // ВЛ11М
    885: Result := $724767;   // ВЛ85
    201318: Result := $72477B; // ТЭМ18ДМ
    else
      Result := $3246D5; // По умолчанию для ED4M
  end;
end;

function IsKeyPressed(VKey: Integer): Boolean;
begin
  Result := (GetAsyncKeyState(VKey) and $8000) <> 0;
end;

// Функция для ограничения pitch
function ClampPitch(pitch: Single): Single;
begin
  if pitch > 90.0 then
    Result := 90.0
  else if pitch < -90.0 then
    Result := -90.0
  else
    Result := pitch;
end;

// Функция для чтения Single из памяти
function ReadMemorySingle(Address: Cardinal): Single;
begin
  try
    Result := PSingle(Pointer(Address))^;
  except
    Result := 0.0;
  end;
end;

// Функция для записи Single в память
procedure WriteMemorySingle(Address: Cardinal; Value: Single);
begin
  try
    PSingle(Pointer(Address))^ := Value;
  except
    // Игнорируем ошибки записи
  end;
end;

// Функция для записи Double в память
procedure WriteMemoryDouble(Address: Cardinal; Value: Double);
begin
  try
    PDouble(Pointer(Address))^ := Value;
  except
    // Игнорируем ошибки записи
  end;
end;

function GetLocomotiveTypeFromMemory: Integer;
begin
  try
    // Читаем 4 байта (Integer) из памяти по адресу Launcher.exe+4F8D93C
    Result := PInteger(Pointer($00400000 + $4F8D93C))^;
  except
    // В случае ошибки используем значение по умолчанию
    Result := 822; // ЧС7 по умолчанию
  end;
end;

// Изменить функцию ApplyNopPatch
function ApplyNopPatch: Boolean;
var
  PatchAddress: Cardinal;
  OldProtect: DWORD;
  i: Integer;
  CurrentLocType: Integer;
begin
  Result := False;
  
  try
    // Читаем тип локомотива из памяти вместо переменной
    CurrentLocType := GetLocomotiveTypeFromMemory;
    PatchAddress := GetLocoPatchOffset(CurrentLocType);

    AddToLogFile(EngineLog, IntToStr(PatchAddress));

    if VirtualProtect(Pointer(PatchAddress), 5, PAGE_EXECUTE_READWRITE, OldProtect) then
    begin
      // Сохраняем оригинальные байты
      for i := 0 to 4 do
        OriginalBytes[i] := PByte(PatchAddress + i)^;
      
      // Применяем NOP патч
      for i := 0 to 4 do
        PByte(PatchAddress + i)^ := NopBytes[i];
      
      VirtualProtect(Pointer(PatchAddress), 5, OldProtect, OldProtect);
      Result := True;
      
      AddToLogFile(EngineLog, Format('NOP patch applied for locomotive type %d at address %s',
        [CurrentLocType, IntToHex(PatchAddress, 8)]));
    end;
  except
    on E: Exception do
    begin
      AddToLogFile(EngineLog, 'Error applying NOP patch: ' + E.Message);
      Result := False;
    end;
  end;
end;

// Изменить функцию RestoreOriginalBytes
function RestoreOriginalBytes: Boolean;
var
  PatchAddress: Cardinal;
  OldProtect: DWORD;
  i: Integer;
  CurrentLocType: Integer;
begin
  Result := False;
  
  try
    // Читаем тип локомотива из памяти вместо переменной
    CurrentLocType := GetLocomotiveTypeFromMemory;
    PatchAddress := GetLocoPatchOffset(CurrentLocType);

    if VirtualProtect(Pointer(PatchAddress), 5, PAGE_EXECUTE_READWRITE, OldProtect) then
    begin
      // Восстанавливаем оригинальные байты
      for i := 0 to 4 do
        PByte(PatchAddress + i)^ := OriginalBytes[i];
      
      VirtualProtect(Pointer(PatchAddress), 5, OldProtect, OldProtect);
      // Сброс углов камеры
      WriteMemorySingle(ADDR_LOOKYAW, 0.0);
      WriteMemorySingle(ADDR_LOOKPITCH, 0.0);

      Result := True;
      
      AddToLogFile(EngineLog, Format('Original bytes restored for locomotive type %d at address %s', 
        [CurrentLocType, IntToHex(PatchAddress, 8)]));
    end;
  except
    on E: Exception do
    begin
      AddToLogFile(EngineLog, 'Error restoring original bytes: ' + E.Message);
      Result := False;
    end;
  end;
end;

// Также можно изменить функцию InitializeFreecam для консистентности
procedure InitializeFreecam;
var
  CurrentLocType: Integer;
begin
  if FreecamInitialized then Exit;
  
  try
    // Читаем тип локомотива из памяти
    CurrentLocType := GetLocomotiveTypeFromMemory;
    
    // Читаем начальные значения
    InitialYaw := ReadMemorySingle(ADDR_LOOKYAW);
    InitialPitch := ReadMemorySingle(ADDR_LOOKPITCH);
    InitialX := ReadMemorySingle(ADDR_X);
    InitialY := ReadMemorySingle(ADDR_Y);
    InitialZ := ReadMemorySingle(ADDR_Z);
    
    FreecamInitialized := True;
    
    AddToLogFile(EngineLog, Format('Freecam initialized for locomotive type %d - Yaw: %.2f, Pitch: %.2f, X: %.2f, Y: %.2f, Z: %.2f',
      [CurrentLocType, InitialYaw, InitialPitch, InitialX, InitialY, InitialZ]));
  except
    on E: Exception do
      AddToLogFile(EngineLog, 'Freecam initialization failed: ' + E.Message);
  end;
end;

// Удобная обёртка для работы с обычными строками
procedure DrawText3D(FontID: Integer; Text: string);
var
  TextPtr: PChar;
begin
  TextPtr := PChar(Text);
  Write3D(FontID, TextPtr);
end;


procedure WriteHookAddress; stdcall;
var
  F: TextFile;
  HookAddr: Cardinal;
  CallAddress: Cardinal;
  NewOffset: Integer;
  OldProtect: DWORD;
  i: Integer;
  StartTime: Cardinal;


  // Адреса для замены PUSH инструкций
  SpeedXAddr: Cardinal;
  AllowedSpeedAddr: Cardinal;
  ShuntingSpeedAddr: Cardinal;
  TrainSpeedAddr: Cardinal;
  TimeAddr: Cardinal;
  NumberAccelAddr: Cardinal;
  ReverseAddr: Cardinal;
  AdditionalAddr: Cardinal;
  RadiusAddr: Cardinal;
  
  // Новые значения для замены (в формате little-endian)
  NewSpeedXValue: array[0..3] of Byte;
  NewAllowedSpeedValue: array[0..3] of Byte;
  NewShuntingSpeedValue: array[0..3] of Byte;
  NewTrainSpeedValue: array[0..3] of Byte;
  NewTimeValue: array[0..3] of Byte;
  NewNumberAccelValue: array[0..3] of Byte;
  NewReverseValue: array[0..3] of Byte;
  NewAdditionalValue: array[0..3] of Byte;

    function SafeVirtualProtect(Address: Pointer; Size: Cardinal; NewProtect: DWORD; var OldProtect: DWORD): Boolean;
  var
    AttemptStart: Cardinal;
    Attempts: Integer;
  begin
    AttemptStart := GetTickCount;
    Result := False;
    Attempts := 0;
    
    repeat
      try
        Result := VirtualProtect(Address, Size, NewProtect, OldProtect);
        if Result then Break;
        
        Inc(Attempts);
//        Sleep(1); // Небольшая пауза между попытками

        // Если больше 10 попыток или прошло больше секунды - выходим
        if (Attempts > 10) or ((GetTickCount - AttemptStart) > 1000) then
          Break;
          
      except
        // Игнорируем исключения и пробуем еще раз
        Inc(Attempts);
        if Attempts > 5 then Break;
      end;
    until False;
  end;

  function IsTimeoutExceeded: Boolean;
  begin
    Result := (GetTickCount - StartTime) > 3000; // 3 секунды тайм-аут
  end;

begin
  StartTime := GetTickCount;



  try
    // Быстрое получение адреса
    try
      HookAddr := Cardinal(@HookKLUB);
    except
      Exit; // Если не можем получить адрес, выходим
    end;
    
    // Быстрая запись в файл без излишних проверок
    try
      AssignFile(F, 'hook.txt');
      Rewrite(F);
      WriteLn(F, IntToStr(HookAddr));
      CloseFile(F);
    except
      // Если не можем записать в файл, продолжаем без него
    end;
    
    if IsTimeoutExceeded then Exit;
    
    // Основная операция патчинга с тайм-аутом
    try
      CallAddress := $00400000 + $277938;
      NewOffset := Integer(HookAddr) - Integer(CallAddress + 5);
      
      if SafeVirtualProtect(Pointer(CallAddress + 1), 4, PAGE_EXECUTE_READWRITE, OldProtect) then
      begin
        try
          PInteger(CallAddress + 1)^ := NewOffset;
          SafeVirtualProtect(Pointer(CallAddress + 1), 4, OldProtect, OldProtect);
        except
          // Игнорируем ошибки записи
        end;
      end;
    except
      // Игнорируем ошибки основного патчинга
    end;
    
    if IsTimeoutExceeded then Exit;
    
    // Инициализируем адреса PUSH инструкций
//    SpeedXAddr := $00400000 + $84B2A + 1;
//    AllowedSpeedAddr := $00400000 + $84D24 + 1;
//    ShuntingSpeedAddr := $00400000 + $853C5 + 1;
//    TrainSpeedAddr := $00400000 + $853DF + 1;
//    TimeAddr := $00400000 + $854B0 + 1;
//    NumberAccelAddr := $00400000 + $85978 + 1;
//    ReverseAddr := $00400000 + $84CA2 + 1;
//    AdditionalAddr := $00400000 + $8562F + 1;
//    RadiusAddr := $485F40;
//    
//    // Устанавливаем значения для PUSH
//    NewSpeedXValue[0] := $7B; NewSpeedXValue[1] := $12; NewSpeedXValue[2] := $83; NewSpeedXValue[3] := $BB;
//    NewAllowedSpeedValue[0] := $7B; NewAllowedSpeedValue[1] := $12; NewAllowedSpeedValue[2] := $83; NewAllowedSpeedValue[3] := $BB;
//    NewShuntingSpeedValue[0] := $BD; NewShuntingSpeedValue[1] := $CA; NewShuntingSpeedValue[2] := $A1; NewShuntingSpeedValue[3] := $3D;
//    NewTrainSpeedValue[0] := $5A; NewTrainSpeedValue[1] := $E3; NewTrainSpeedValue[2] := $A5; NewTrainSpeedValue[3] := $3D;
//    NewTimeValue[0] := $46; NewTimeValue[1] := $60; NewTimeValue[2] := $E5; NewTimeValue[3] := $3C;
//    NewNumberAccelValue[0] := $91; NewNumberAccelValue[1] := $C2; NewNumberAccelValue[2] := $F5; NewNumberAccelValue[3] := $3C;
//    NewReverseValue[0] := $74; NewReverseValue[1] := $12; NewReverseValue[2] := $03; NewReverseValue[3] := $3B;
//    NewAdditionalValue[0] := $E9; NewAdditionalValue[1] := $FD; NewAdditionalValue[2] := $54; NewAdditionalValue[3] := $3D;
//

    // Быстрое применение всех патчей с проверкой тайм-аута
    try
      // Скорость X
      if not IsTimeoutExceeded and SafeVirtualProtect(Pointer(SpeedXAddr), 4, PAGE_EXECUTE_READWRITE, OldProtect) then
      begin
        try
          for i := 0 to 3 do
            PByte(SpeedXAddr + i)^ := NewSpeedXValue[i];
          SafeVirtualProtect(Pointer(SpeedXAddr), 4, OldProtect, OldProtect);
        except
          // Игнорируем ошибки
        end;
      end;
      
      // Допустимая скорость
      if not IsTimeoutExceeded and SafeVirtualProtect(Pointer(AllowedSpeedAddr), 4, PAGE_EXECUTE_READWRITE, OldProtect) then
      begin
        try
          for i := 0 to 3 do
            PByte(AllowedSpeedAddr + i)^ := NewAllowedSpeedValue[i];
          SafeVirtualProtect(Pointer(AllowedSpeedAddr), 4, OldProtect, OldProtect);
        except
          // Игнорируем ошибки
        end;
      end;
      
      // Остальные патчи применяем аналогично, но с проверкой тайм-аута
      if not IsTimeoutExceeded then
      begin
        // Маневровый режим
        if SafeVirtualProtect(Pointer(ShuntingSpeedAddr), 4, PAGE_EXECUTE_READWRITE, OldProtect) then
        begin
          try
            for i := 0 to 3 do
              PByte(ShuntingSpeedAddr + i)^ := NewShuntingSpeedValue[i];
            SafeVirtualProtect(Pointer(ShuntingSpeedAddr), 4, OldProtect, OldProtect);
          except
            // Игнорируем ошибки
          end;
        end;
        
        // Поездной режим
        if SafeVirtualProtect(Pointer(TrainSpeedAddr), 4, PAGE_EXECUTE_READWRITE, OldProtect) then
        begin
          try
            for i := 0 to 3 do
              PByte(TrainSpeedAddr + i)^ := NewTrainSpeedValue[i];
            SafeVirtualProtect(Pointer(TrainSpeedAddr), 4, OldProtect, OldProtect);
          except
            // Игнорируем ошибки
          end;
        end;
        
        // Время
        if SafeVirtualProtect(Pointer(TimeAddr), 4, PAGE_EXECUTE_READWRITE, OldProtect) then
        begin
          try
            for i := 0 to 3 do
              PByte(TimeAddr + i)^ := NewTimeValue[i];
            SafeVirtualProtect(Pointer(TimeAddr), 4, OldProtect, OldProtect);
          except
            // Игнорируем ошибки
          end;
        end;
        
        // Номер и ускорение
        if SafeVirtualProtect(Pointer(NumberAccelAddr), 4, PAGE_EXECUTE_READWRITE, OldProtect) then
        begin
          try
            for i := 0 to 3 do
              PByte(NumberAccelAddr + i)^ := NewNumberAccelValue[i];
            SafeVirtualProtect(Pointer(NumberAccelAddr), 4, OldProtect, OldProtect);
          except
            // Игнорируем ошибки
          end;
        end;
        
        // Реверс
        if SafeVirtualProtect(Pointer(ReverseAddr), 4, PAGE_EXECUTE_READWRITE, OldProtect) then
        begin
          try
            for i := 0 to 3 do
              PByte(ReverseAddr + i)^ := NewReverseValue[i];
            SafeVirtualProtect(Pointer(ReverseAddr), 4, OldProtect, OldProtect);
          except
            // Игнорируем ошибки
          end;
        end;
        
        // Дополнительный параметр
        if SafeVirtualProtect(Pointer(AdditionalAddr), 4, PAGE_EXECUTE_READWRITE, OldProtect) then
        begin
          try
            for i := 0 to 3 do
              PByte(AdditionalAddr + i)^ := NewAdditionalValue[i];
            SafeVirtualProtect(Pointer(AdditionalAddr), 4, OldProtect, OldProtect);
          except
            // Игнорируем ошибки
          end;
        end;
        
        // Обнуляем массив радиуса
        if SafeVirtualProtect(Pointer(RadiusAddr), 10, PAGE_EXECUTE_READWRITE, OldProtect) then
        begin
          try
            for i := 0 to 9 do
              PByte(RadiusAddr + i)^ := $00;
            SafeVirtualProtect(Pointer(RadiusAddr), 10, OldProtect, OldProtect);
          except
            // Игнорируем ошибки
          end;
        end;
      end;
      
    except
      // Игнорируем любые ошибки в патчинге
    end;
    
  except
    on E: Exception do
    begin
      // Записываем ошибку в лог только если это возможно
      try
        //AddToLogFile(EngineLog, 'WriteHookAddress error: ' + E.Message);
      except
        // Если даже запись в лог не работает, просто выходим
      end;
    end;
  end;

end;

{System------------------------------------------------------------------------}
function vertex(x,y,z : single) : TVertex; inline;
begin
result.X:=x;
result.Y:=y;
result.Z:=z;
end;
{------------------------------------------------------------------}
function GETLIGHT(ID: integer) : integer;
begin
 result:=GL_LIGHT0+ID;
end;
{------------------------------------------------------------------}
procedure _glTexCoord2f(X,Y : GLFloat; Layer : integer = -1); stdcall;
var i : cardinal;
begin

 if MultyTexActive then
 begin
  if Layer=-1 then
  begin
   glMultiTexCoord2fARB(GL_TEXTURE0_ARB,X,Y);
  for i:=1 to 5 do
   glMultiTexCoord2fARB(GL_TEXTURE0_ARB+i, (X+MultyCoordOffset[i][0])*MultyCoordOffset[i][2],
    (Y+MultyCoordOffset[i][1])*MultyCoordOffset[i][3]);
  end else glMultiTexCoord2fARB(GL_TEXTURE0_ARB+Layer,X,Y);
 end else glTexCoord2f(x,y);

end;
{------------------------------------------------------------------}
procedure _glTexCoord3f(X,Y,Z : GLFloat; Layer : integer = -1);
var i : cardinal;
begin

 if MultyTexActive then
 begin
  if Layer=-1 then
  begin
   glMultiTexCoord3fARB(GL_TEXTURE0_ARB,X,Y,Z);
  for i:=1 to 5 do
   glMultiTexCoord3fARB(GL_TEXTURE0_ARB+i, (X+MultyCoordOffset[i][0])*MultyCoordOffset[i][2],
    (Y+MultyCoordOffset[i][1])*MultyCoordOffset[i][3],0);
  end else glMultiTexCoord3fARB(GL_TEXTURE0_ARB+Layer,X,Y,Z);
 end else glTexCoord3f(x,y,z);

end;
{------------------------------------------------------------------}
procedure CullFace(Mode : cardinal); stdcall;
begin
  case mode of
  0:glDisable(GL_CULL_FACE);
  1:
  begin
  glEnable(GL_CULL_FACE);
  glCullFace(GL_FRONT);
  end;
  2:
  begin
  glEnable(GL_CULL_FACE);
  glCullFace(GL_BACK);
  end;
  end;
end;
{------------------------------------------------------------------}
procedure InitFBO(Texw, texh, ZBuf : cardinal);
var comp : integer;
begin
 if GL_EXT_framebuffer_object and
 (
 ((fbo_w<>Texw) or (fbo_h<>Texh)) or (fbo_z<>ZBuf) or ((fbo_frame=0) or (fbo_depth=0))
 )then
  begin

  fbo_w := Texw;
  fbo_h := Texh;

  if fbo_frame <> 0 then glDeleteFramebuffersEXT(1, @fbo_frame);
  if fbo_depth <> 0 then glDeleteRenderbuffersEXT(1, @fbo_depth);

  glGenFramebuffersEXT(1, @fbo_frame);
  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo_frame);

  glGenRenderbuffersEXT(1, @fbo_depth);
  glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, fbo_depth);

  case ZBuf of
  16:comp:=GL_DEPTH_COMPONENT16_ARB;
  24:comp:=GL_DEPTH_COMPONENT24_ARB;
  32:comp:=GL_DEPTH_COMPONENT32_ARB;
  else
  begin
    AddToLogFile(EngineLog,'ZBuffer depth is incirrect');
    comp:=GL_DEPTH_COMPONENT24_ARB;
  end;
  end;

  glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, comp, Texw, Texh);
 	glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, fbo_depth);
  glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0);

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
  end;
end;
{------------------------------------------------------------------}
procedure InitEng;

   procedure CreateSphere(CX, CY, CZ, Radius : glFloat; N : Integer);  // N = precision
    var I, J : Integer;
        theta1,theta2,theta3 : glFloat;
        X, Y, Z, px, py, pz : glFloat;
    begin
      SphereDL :=glGenLists(1);
      glNewList(SphereDL, GL_COMPILE);

        if Radius < 0 then Radius :=-Radius;
        if n < 0 then n := -n;
        if (n < 4) OR (Radius <= 0) then
        begin
          glBegin(GL_POINTS);
            glVertex3f(CX, CY, CZ);
          glEnd();
          exit;
        end;

        for J :=0 to N DIV 2 -1 do
        begin
          theta1 := J*2*PI/N - PI/2;
          theta2 := (J+1)*2*PI/n - PI/2;
          glBegin(GL_QUAD_STRIP);
            For I :=0 to N do
            begin
              theta3 := i*2*PI/N;
              x := cos(theta2) * cos(theta3);
              y := sin(theta2);
              z := cos(theta2) * sin(theta3);
              px := CX + Radius*x;
              py := CY + Radius*y;
              pz := CZ + Radius*z;

              glNormal3f(X, Y, Z);
              _glTexCoord2f(1-I/n, 2*(J+1)/n);
              glVertex3f(px,py,pz);

              X := cos(theta1) * cos(theta3);
              Y := sin(theta1);
              Z := cos(theta1) * sin(theta3);
              px := CX + Radius*X;
              py := CY + Radius*Y;
              pz := CZ + Radius*Z;

              glNormal3f(X, Y, Z);
              _glTexCoord2f(1-i/n, 2*j/n);
              glVertex3f(px,py,pz);
            end;
          glEnd();
        end;
      glEndList();
    end;

var i : integer;
begin

if GL_ARB_multitexture then
begin

 for i:=1 to 5 do
 begin
  glActiveTextureARB(GL_TEXTURE0_ARB+i);
  glBindTexture(GL_TEXTURE_2D, 0);

  MultyCoordOffset[i][0]:=0.0;
  MultyCoordOffset[i][1]:=0.0;
  MultyCoordOffset[i][2]:=1.0;
  MultyCoordOffset[i][3]:=1.0;
 end;

 glActiveTextureARB(GL_TEXTURE0_ARB);
 glEnable(GL_TEXTURE_2D);
 glBindTexture(GL_TEXTURE_2D, 0);

end;

for i:=0 to 20 do
 LightsOn[i]:=False;

CreateSphere(0, 0, 0, 1, 48);

QuadraticObject := gluNewQuadric;
gluQuadricNormals(QuadraticObject, GLU_SMOOTH);

//_NormCubemap:=GenerateNormalisationCubeMap;

fbo_frame:=0;
fbo_depth:=0;
fbo_w:=0;
fbo_h:=0;
fbo_z:=0;

if GL_EXT_framebuffer_object then
glGenFramebuffersEXT(1, @fbo2);

end;
{------------------------------------------------------------------}
procedure FreeEng;
var 
  i: integer;
  Count: cardinal;
  TotalFreed: Integer;
  StartTime: Cardinal;
  OperationTimeout: Boolean;
begin
  StartTime := GetTickCount;
  TotalFreed := 0;
  OperationTimeout := False;

  try
    // Проверяем тайм-аут на каждом этапе
    if (GetTickCount - StartTime) > 5000 then
    begin
      OperationTimeout := True;
      Exit;
    end;

    // Освобождаем QuadraticObject
    try
      if QuadraticObject <> nil then
      begin
        gluDeleteQuadric(QuadraticObject);
        QuadraticObject := nil;
      end;
    except
      // Игнорируем ошибки OpenGL
    end;

    // Освобождаем SphereDL
    try
      if SphereDL <> 0 then
      begin
        glDeleteLists(SphereDL, 1);
        SphereDL := 0;
      end;
    except
      // Игнорируем ошибки OpenGL
    end;

    // Проверяем тайм-аут
    if (GetTickCount - StartTime) > 5000 then
    begin
      OperationTimeout := True;
      Exit;
    end;

    // Освобождаем FBO
    try
      if GL_EXT_framebuffer_object then
      begin
        if fbo2 <> 0 then
        begin
          glDeleteFramebuffersEXT(1, @fbo2);
          fbo2 := 0;
        end;
        if fbo_frame <> 0 then
        begin
          glDeleteFramebuffersEXT(1, @fbo_frame);
          fbo_frame := 0;
        end;
        if fbo_depth <> 0 then
        begin
          glDeleteRenderbuffersEXT(1, @fbo_depth);
          fbo_depth := 0;
        end;
      end;
    except
      // Игнорируем ошибки OpenGL
    end;

    // Очищаем массивы
    Obj3DInfo := nil;

    // Проверяем тайм-аут
    if (GetTickCount - StartTime) > 5000 then
    begin
      OperationTimeout := True;
      Exit;
    end;

    // Освобождаем AVI текстуры
    Count := 0;
    try
      if AvisCount <> 0 then
      begin
        for i := 0 to AvisCount - 1 do
        begin
          if Avis[i].loaded then
          begin
            try
              FreeAVITexture(i);
              Inc(Count);
            except
              // Игнорируем ошибки при освобождении AVI
            end;
          end;
          
          // Проверяем тайм-аут внутри цикла
          if (GetTickCount - StartTime) > 5000 then
          begin
            OperationTimeout := True;
            Break;
          end;
        end;
        TotalFreed := TotalFreed + Count;
      end;
      Avis := nil;
      AvisCount := 0;
    except
      // Игнорируем ошибки массива AVI
    end;

    // Проверяем тайм-аут
    if OperationTimeout or ((GetTickCount - StartTime) > 5000) then
      Exit;

    // Освобождаем 3D шрифты
    Count := 0;
    try
      if FontsCount > 0 then
      begin
        for i := 0 to FontsCount - 1 do
        begin
          try
            if Fonts3D[i].List <> 0 then
            begin
              glDeleteLists(Fonts3D[i].List, 256);
              Inc(Count);
            end;
          except
            // Игнорируем ошибки OpenGL
          end;
          
          // Проверяем тайм-аут
          if (GetTickCount - StartTime) > 5000 then
          begin
            OperationTimeout := True;
            Break;
          end;
        end;
        TotalFreed := TotalFreed + Count;
      end;
      Fonts3D := nil;
      FontsCount := 0;
    except
      // Игнорируем ошибки массива шрифтов
    end;

    // Проверяем тайм-аут
    if OperationTimeout or ((GetTickCount - StartTime) > 5000) then
      Exit;

    // Освобождаем сцены
    Count := 0;
    try
      if ScenesCount > 0 then
      begin
        for i := 0 to ScenesCount - 1 do
        begin
          try
            FreeScene(Scenes[i].uid);
            Inc(Count);
          except
            // Игнорируем ошибки при освобождении сцен
          end;
          
          // Проверяем тайм-аут
          if (GetTickCount - StartTime) > 5000 then
          begin
            OperationTimeout := True;
            Break;
          end;
        end;
        TotalFreed := TotalFreed + Count;
      end;
      Scenes := nil;
      ScenesCount := 0;
    except
      // Игнорируем ошибки массива сцен
    end;

    // Проверяем тайм-аут
    if OperationTimeout or ((GetTickCount - StartTime) > 5000) then
      Exit;

    // Освобождаем шейдеры
    Count := 0;
    try
      if ShadersCount > 0 then
      begin
        for i := 0 to ShadersCount - 1 do
        begin
          try
            if Shaders[i].glident <> 0 then
            begin
              glDeleteProgramsARB(1, @Shaders[i].glident);
              Inc(Count);
            end;
          except
            // Игнорируем ошибки OpenGL
          end;
          
          // Проверяем тайм-аут
          if (GetTickCount - StartTime) > 5000 then
          begin
            OperationTimeout := True;
            Break;
          end;
        end;
        TotalFreed := TotalFreed + Count;
      end;
      Shaders := nil;
      ShadersCount := 0;
    except
      // Игнорируем ошибки массива шейдеров
    end;

    // Проверяем тайм-аут
    if OperationTimeout or ((GetTickCount - StartTime) > 5000) then
      Exit;

    // Освобождаем меши
    Count := 0;
    try
      if MeshsCount > 0 then
      begin
        for i := 0 to MeshsCount - 1 do
        begin
          try
            if Assigned(Meshs[i].Mesh) then
            begin
              Meshs[i].Mesh.Free;
              Meshs[i].Mesh := nil;
              Inc(Count);
            end;
          except
            // Игнорируем ошибки при освобождении мешей
          end;
          
          // Проверяем тайм-аут
          if (GetTickCount - StartTime) > 5000 then
          begin
            OperationTimeout := True;
            Break;
          end;
        end;
        TotalFreed := TotalFreed + Count;
      end;
      Meshs := nil;
      MeshsCount := 0;
    except
      // Игнорируем ошибки массива мешей
    end;

    // Проверяем тайм-аут
    if OperationTimeout or ((GetTickCount - StartTime) > 5000) then
      Exit;

    // Освобождаем лого
    try
      if ShowLogo and (Logo <> 0) then
      begin
        FreeTexture(Logo);
        Logo := 0;
      end;
    except
      // Игнорируем ошибки с лого
    end;

    // Освобождаем текстуры
    Count := 0;
    try
      if length(TexturesInfo) > 0 then
      begin
        for i := 0 to length(TexturesInfo) - 1 do
        begin
          try
            if TexturesInfo[i].Index <> 0 then
            begin
              glDeleteTextures(1, @TexturesInfo[i].Index);
              Inc(Count);
            end;
          except
            // Игнорируем ошибки OpenGL
          end;
          
          // Проверяем тайм-аут
          if (GetTickCount - StartTime) > 5000 then
          begin
            OperationTimeout := True;
            Break;
          end;
        end;
        TotalFreed := TotalFreed + Count;
      end;
      TexturesInfo := nil;
    except
      // Игнорируем ошибки массива текстур
    end;

    // Проверяем тайм-аут
    if OperationTimeout or ((GetTickCount - StartTime) > 5000) then
      Exit;

    // Освобождаем DGL шрифты
    Count := 0;
    try
      if length(DGLFonts) > 0 then
      begin
        for i := 0 to length(DGLFonts) - 1 do
        begin
          if DGLFonts[i].Load then
          begin
            try
              if DGLFonts[i].Texture <> 0 then
              begin
                glDeleteTextures(1, @DGLFonts[i].Texture);
                Inc(Count);
              end;
            except
              // Игнорируем ошибки OpenGL
            end;
          end;
          
          // Проверяем тайм-аут
          if (GetTickCount - StartTime) > 5000 then
          begin
            OperationTimeout := True;
            Break;
          end;
        end;
        TotalFreed := TotalFreed + Count;
      end;
      DGLFonts := nil;
    except
      // Игнорируем ошибки массива DGL шрифтов
    end;

    // Освобождаем StringList'ы из трафик системы
    try
      if Assigned(s1) then
      begin
        s1.Free;
        s1 := nil;
      end;
    except
      // Игнорируем ошибки
    end;

    try
      if Assigned(s2) then
      begin
        s2.Free;
        s2 := nil;
      end;
    except
      // Игнорируем ошибки
    end;

    // ОДНА запись в лог вместо множественных
    try
      if TotalFreed > 0 then
        //AddToLogFile(EngineLog, Format('Engine cleanup completed: %d resources freed in %d ms',
          //[TotalFreed, GetTickCount - StartTime]))
      else if not OperationTimeout then
        //AddToLogFile(EngineLog, 'Engine cleanup completed.');

      if OperationTimeout then
        //AddToLogFile(EngineLog, 'Engine cleanup timeout exceeded, forced shutdown.');
    except
      // Если даже запись в лог не работает, ничего не делаем
    end;

  except
    on E: Exception do
    begin
      // Последняя попытка записать об ошибке
      try
        //AddToLogFile(EngineLog, 'Critical error during engine cleanup: ' + E.Message);
      except
        // Если и это не работает, просто выходим
      end;
    end;
  end;
end;

{Scenes -----------------------------------------------------------------------}
procedure SceneSetObjActive( SceneIdent, ObjIdent : cardinal; Active : boolean ); stdcall;
var i : integer;
begin
if ScenesCount>0 then
 for i := 0 to ScenesCount - 1 do
  if SceneIdent=Scenes[i].uid then
  begin
    Scenes[i].Models[ObjIdent].Active:=Active;
    Exit;
  end;
end;
{------------------------------------------------------------------}
procedure SceneSetObj( SceneIdent, ObjIdent : cardinal; SceneMesh : TSceneMesh ); stdcall;
var i : integer;
begin
if ScenesCount>0 then
 for i := 0 to ScenesCount - 1 do
  if SceneIdent=Scenes[i].uid then
  begin
    Scenes[i].Models[ObjIdent]:= SceneMesh;
    Exit;
  end;
end;
{------------------------------------------------------------------}
function SceneGetObj( SceneIdent, ObjIdent : cardinal ) : TSceneMesh; stdcall;
var i : integer;
begin
if ScenesCount>0 then
 for i := 0 to ScenesCount - 1 do
  if SceneIdent=Scenes[i].uid then
  begin
    result:=Scenes[i].Models[ObjIdent];
    Exit;
  end;
end;
{------------------------------------------------------------------}
function GetSceneObjectIdent( SceneIdent : cardinal; ObjName : string ) : integer; stdcall;
var i,j : integer;
begin
result:=-1;
if ScenesCount>0 then
 for i := 0 to ScenesCount - 1 do
  if SceneIdent=Scenes[i].uid then
  begin
    result:=-1;
    if length(Scenes[i].Models)>0 then
    for j := 0 to length(Scenes[i].Models) - 1 do
     if ObjName = Scenes[i].Models[j].Name then
     begin
       result:=j;
       Exit;
     end;
    Exit;
  end;
end;
{------------------------------------------------------------------}
function SceneGetLastCollideObjectIndex:integer; stdcall;
begin
  result:=LastCollide;
end;
{------------------------------------------------------------------}
function SceneObjCount( Ident : cardinal ) : cardinal; stdcall;
var i : integer;
begin
result:=0;
if ScenesCount>0 then
 for i := 0 to ScenesCount - 1 do
  if Ident=Scenes[i].uid then
  begin
    result:=length(Scenes[i].Models);
    Exit;
  end;
end;
{------------------------------------------------------------------}
function CollideBoxWithScene(Ident : cardinal; BoxPos, BoxSize : Tvertex):boolean; stdcall;

  type
  TPhysicsBoundBox = record
  Min, Max: TVertex;
  end;

  function BoundBoxIntersect(const BoundBox, WithBoundBox: TPhysicsBoundBox): boolean;
  begin                      
   Result :=
    ((BoundBox.Max.x >= WithBoundBox.Min.x) and
    (BoundBox.Min.x <= WithBoundBox.Max.x)) and
    ((BoundBox.Max.y >= WithBoundBox.Min.y) and
    (BoundBox.Min.y <= WithBoundBox.Max.y)) and
    ((BoundBox.Max.z >= WithBoundBox.Min.z) and
    (BoundBox.Min.z <= WithBoundBox.Max.z));
  end;

  function PhysicsBoundBox (minx, miny, minz, maxx, maxy, maxz : single):TPhysicsBoundBox; inline;
  begin
   result.Min.X:=minx;
   result.Min.Y:=miny;
   result.Min.Z:=minz;
   result.Max.X:=maxx;
   result.Max.Y:=maxy;
   result.Max.Z:=maxz;
  end;

  var
  i,j : integer;
  mbound : Tvertex;
  cur,cur2 : TPhysicsBoundBox;
begin
 result := false;

 cur := PhysicsBoundBox(BoxPos.X-BoxSize.X/2,BoxPos.Y-BoxSize.Y/2,BoxPos.Z-BoxSize.Z/2,
                        BoxPos.X+BoxSize.X/2,BoxPos.Y+BoxSize.Y/2,BoxPos.Z+BoxSize.Z/2);

 LastCollide:=-1;

 if ScenesCount>0 then
 for j := 0 to ScenesCount - 1 do
 if Ident=Scenes[j].uid then
 begin
 if length(Scenes[j].Models)>0 then
  for i := 0 to length(Scenes[j].Models) - 1 do
  if Scenes[j].Models[i].Active then
  begin

   mbound:=ModelBoundingBox(Scenes[j].models[i].Mesh,0);

   with Scenes[j].models[i] do
   cur2 := PhysicsBoundBox(
   Pos.X-(mbound.X*Scale)/2,Pos.Y-(mbound.Y*Scale)/2,Pos.Z-(mbound.Z*Scale)/2,
   Pos.X+(mbound.X*Scale)/2,Pos.Y+(mbound.Y*Scale)/2,Pos.Z+(mbound.Z*Scale)/2
   );

   if BoundBoxIntersect(cur,cur2) then
   begin
     result:=true;
     LastCollide:=i;
     Exit;
   end;

  end;

 Exit;
 end;
end;
{------------------------------------------------------------------}
function LoadScene(FileName, MeshPath, TexPath : string):cardinal; stdcall;
var
F : textfile;
s : string;
MeshFromPak, TxtFromPak : boolean;

procedure ReadEntity;
var
t : TSceneMesh;
i : integer;
a,b,c : single;
found : boolean;
begin
 Readln(f,S);
 Readln(f,S);
 Readln(f,S);
 Readln(f,S);
 t.Name:=s;
 if not MeshFromPak then
 t.Mesh:=LoadModel(MeshPath+'\'+s+'.dmd',0,false)
 else
 begin
  ExtractFromPackage(MeshPath,s+'.dmd','temp.dmd');
  t.Mesh:=LoadModel('temp.dmd',0,false);
  DeleteFile('temp.dmd');
 end;
 Readln(f,S);
 Readln(f,a,b,c);
 t.Pos.X:=a;
 t.Pos.Y:=b;
 t.Pos.Z:=c;
 Readln(f,S);
 Readln(f,t.Scale);
 t.Material:=ModelMaterial(t.Mesh);

 if t.Material.TexFileName<>'None' then
 begin

 found:=false;

 if length(Scenes[ScenesCount-1].Models)-1>0 then
  for i := 0 to length(Scenes[ScenesCount-1].Models)-1 do
   if t.Material.TexFileName=Scenes[ScenesCount-1].Models[i].Material.TexFileName then
   begin
     t.Texture:=Scenes[ScenesCount-1].Models[i].Texture;
     found:=true;
     break;
   end;

  if not found then
    if not TxtFromPak then
    t.Texture:=LoadTextureFromFile(TexPath+'\'+t.Material.TexFileName,0,-1)
    else
    t.Texture:=LoadTextureFromPackage(TexPath,t.Material.TexFileName,0,-1);

 end else t.Texture:=0;

 if t.Material.NormalMapFileName<>'None' then
 begin

 found:=false;

 if length(Scenes[ScenesCount-1].Models)-1>0 then
  for i := 0 to length(Scenes[ScenesCount-1].Models)-1 do
   if t.Material.NormalMapFileName=Scenes[ScenesCount-1].Models[i].Material.NormalMapFileName then
   begin
     t.BumpTexture:=Scenes[ScenesCount-1].Models[i].BumpTexture;
     found:=true;
     break;
   end;

  if not found then
    if not TxtFromPak then
    t.BumpTexture:=LoadTextureFromFile(TexPath+'\'+t.Material.NormalMapFileName,0,-1)
    else
    t.BumpTexture:=LoadTextureFromPackage(TexPath,t.Material.NormalMapFileName,0,-1);

 end else t.BumpTexture:=0;

 if t.Material.SpecularMapFileName<>'None' then
 begin

 found:=false;

 if length(Scenes[ScenesCount-1].Models)-1>0 then
  for i := 0 to length(Scenes[ScenesCount-1].Models)-1 do
   if t.Material.SpecularMapFileName=Scenes[ScenesCount-1].Models[i].Material.SpecularMapFileName then
   begin
     t.SpecTexture:=Scenes[ScenesCount-1].Models[i].SpecTexture;
     found:=true;
     break;
   end;

  if not found then
    if not TxtFromPak then
    t.SpecTexture:=LoadTextureFromFile(TexPath+'\'+t.Material.SpecularMapFileName,0,-1)
    else
    t.SpecTexture:=LoadTextureFromPackage(TexPath,t.Material.SpecularMapFileName,0,-1);

 end else t.SpecTexture:=0;

 t.Active:=true;
 t.DoBump:=false;
 t.MeshSmooth:=true;
 t.MeshFrame:=0;

 SetLength(Scenes[ScenesCount-1].Models,length(Scenes[ScenesCount-1].Models)+1);
 Scenes[ScenesCount-1].Models[length(Scenes[ScenesCount-1].Models)-1]:=t;

end;

begin
if fileexists(FileName) then
begin
    TxtFromPak  := copy(Uppercase(TexPath), length(TexPath)-3, 4) = '.DPC';
    MeshFromPak := copy(Uppercase(MeshPath), length(MeshPath)-3, 4) = '.DPC';

    SetLength(Scenes,ScenesCount+1);
    ScenesCount:=ScenesCount+1;
    ScenesOverall:=ScenesOverall+1;
    Scenes[ScenesCount-1].uid:=ScenesOverall;
    SetLength(Scenes[ScenesCount-1].Models,0);
   AssignFile(f,FileName);
   Reset(f);
   while not Eof(f) do begin
     Readln(f,S);
     if S = 'Entity()' then ReadEntity;
   end;
   CloseFile(F);
   result:=ScenesOverall;
end else
begin
AddToLogFile(EngineLog,'"'+FileName+'" scene file not found.');
result:=0;
end;
end;
{------------------------------------------------------------------}
procedure FreeScene(Ident : cardinal); stdcall;
var i,j : integer;
t : TScene;
begin
 if ScenesCount>0 then
  for i := 0 to ScenesCount - 1 do
  if Ident=Scenes[i].uid then
  begin

    if length(Scenes[i].Models)>0 then
    for j := 0 to length(Scenes[i].Models) - 1 do
    begin
      FreeModel(Scenes[i].Models[j].Mesh);
      if Scenes[i].Models[j].Texture<>0 then
      FreeTexture(Scenes[i].Models[j].Texture);
      if Scenes[i].Models[j].BumpTexture<>0 then
      FreeTexture(Scenes[i].Models[j].BumpTexture);
      if Scenes[i].Models[j].SpecTexture<>0 then
      FreeTexture(Scenes[i].Models[j].SpecTexture);
    end;

    if ScenesCount>1 then
    begin

      t.uid:=Scenes[ScenesCount-1].uid;
      SetLength(t.Models,length(Scenes[ScenesCount-1].Models));
      if length(Scenes[ScenesCount-1].Models)>0 then
       for j := 0 to length(t.Models) - 1 do
        t.Models[j]:=Scenes[ScenesCount-1].Models[j];

      Scenes[i].uid:=t.uid;
       SetLength(Scenes[i].Models,length(t.Models));
      if length(t.Models)>0 then
       for j := 0 to length(t.Models) - 1 do
        Scenes[i].Models[j]:=t.Models[j];

    end;

    ScenesCount:=ScenesCount-1;
    SetLength(Scenes,ScenesCount);

    Exit;
  end;
end;
{------------------------------------------------------------------}
procedure DrawScene(Ident : cardinal);stdcall;
var i,j : integer;
t : Tvertex; alpha : byte; atest : boolean;
begin
if ScenesCount>0 then
for j := 0 to ScenesCount - 1 do
if Ident=Scenes[j].uid then
begin
if not _SceneDontUseMat then
BeginObj3D;
 if length(Scenes[j].Models)>0 then
  for i := 0 to length(Scenes[j].Models) - 1 do
   begin
   t:=ModelBoundingBox(Scenes[j].Models[i].Mesh,0);
   if (not _frustumcalculated or IsBoxInFrustum(Scenes[j].Models[i].Pos.X,Scenes[j].Models[i].Pos.Y,Scenes[j].Models[i].Pos.Z,
      t.X*Scenes[j].Models[i].Scale,t.y*Scenes[j].Models[i].Scale,t.z*Scenes[j].Models[i].Scale)) and Scenes[j].Models[i].Active
   then
    begin
     glPushMatrix();

      glTranslatef(Scenes[j].Models[i].Pos.X,Scenes[j].Models[i].Pos.Y,Scenes[j].Models[i].Pos.Z);
      glScalef(Scenes[j].Models[i].Scale,Scenes[j].Models[i].Scale,Scenes[j].Models[i].Scale);

      atest:=false;

      if not _SceneDontUseMat then
      begin

      if not Scenes[j].Models[i].DoBump or (Scenes[j].Models[i].DoBump and(Scenes[j].Models[i].BumpTexture=0)) then
      glBindTexture(GL_TEXTURE_2D,Scenes[j].Models[i].Texture)
      else
      begin
        ActivateMultitexturingLayer(0);
        glBindTexture(GL_TEXTURE_2D,Scenes[j].Models[i].Texture);
        ActivateMultitexturingLayer(1);
        glBindTexture(GL_TEXTURE_2D,Scenes[j].Models[i].BumpTexture);
        ActivateMultitexturingLayer(2);
        glBindTexture(GL_TEXTURE_2D,Scenes[j].Models[i].SpecTexture);
        ActivateMultitexturingLayer(0);
        glEnable(GL_VERTEX_PROGRAM_ARB);
        glEnable(GL_FRAGMENT_PROGRAM_ARB);
        bump_active:=true;
      end;

      if Scenes[j].Models[i].Material.alpha>252 then alpha:=255 else
      if (Scenes[j].Models[i].Material.alpha<255) and (Scenes[j].Models[i].Material.alpha>220) then
      begin
      atest:=true;
      alpha:=255;
      glEnable(GL_ALPHA_TEST);
      glAlphaFunc(GL_GREATER, 0.3);
      end else alpha:=Scenes[j].Models[i].Material.alpha;

      Color3D(RGB(Scenes[j].Models[i].Material.diffuse[0],Scenes[j].Models[i].Material.diffuse[1],Scenes[j].Models[i].Material.diffuse[2]),
      alpha,false,Scenes[j].Models[i].Material.glossiness);

      end;

      DrawModel(Scenes[j].Models[i].Mesh,Scenes[j].Models[i].MeshFrame,Scenes[j].Models[i].MeshSmooth);

      if not _SceneDontUseMat then
      begin

      if atest then glDisable(GL_ALPHA_TEST);
      if Scenes[j].Models[i].DoBump and (Scenes[j].Models[i].BumpTexture<>0) then
      begin
        ActivateMultitexturingLayer(0);
        glBindTexture(GL_TEXTURE_2D,0);
        ActivateMultitexturingLayer(1);
        glBindTexture(GL_TEXTURE_2D,0);
        ActivateMultitexturingLayer(2);
        glBindTexture(GL_TEXTURE_2D,0);
        ActivateMultitexturingLayer(0);
        glDisable(GL_VERTEX_PROGRAM_ARB);
        glDisable(GL_FRAGMENT_PROGRAM_ARB); 
        bump_active:=false;
      end;

      end;

     glPopMatrix();
    end;
   end;
if not _SceneDontUseMat then
EndObj3D;
Exit;
end;
end;
{------------------------------------------------------------------}
function SceneBoundingBox(Ident : cardinal):TVertex; stdcall;
var i, j : integer;
min, max, mbound : Tvertex;
begin

result.X:=0;
result.Y:=0;
result.Z:=0;

if ScenesCount>0 then
for j := 0 to ScenesCount - 1 do
if Ident=Scenes[j].uid then
begin

min:=result;
max:=result;

 if length(Scenes[j].Models)>0 then
  for i := 0 to length(Scenes[j].Models) - 1 do
  with Scenes[j].Models[i] do
  begin

   mbound:=ModelBoundingBox(Mesh,0);

   if max.X<mbound.X+Pos.X then max.X:=mbound.X+Pos.X;
   if max.Y<mbound.Y+Pos.Y then max.Y:=mbound.Y+Pos.Y;
   if max.Z<mbound.Z+Pos.Z then max.Z:=mbound.Z+Pos.Z;

   if min.X>mbound.X+Pos.X then min.X:=mbound.X+Pos.X;
   if min.Y>mbound.Y+Pos.Y then min.Y:=mbound.Y+Pos.Y;
   if min.Z>mbound.Z+Pos.Z then min.Z:=mbound.Z+Pos.Z;

  end;

  result.X:=max.X-min.X;
  result.Y:=max.Y-min.Y;
  result.Z:=max.Z-min.Z;
Exit;
end;
end;
{3D Multy Mesh (models)--------------------------------------------------------}
procedure ModelsBump(Active : boolean); stdcall;
begin
bump_active:=Active;
end;
{------------------------------------------------------------------}
function ModelMaterial(Modelident : integer) : TMaterial; stdcall;
var i : integer; s : TMaterial;
begin
if MeshsCount<>0 then
for i:=0 to MeshsCount-1 do
 if Meshs[i].Ident=ModelIdent then
 begin
  if Meshs[i].Mesh.MaterialPresented then
  result:=Meshs[i].Mesh.Material else
  begin
  s.diffuse[0]:=255;
  s.diffuse[1]:=255;
  s.diffuse[2]:=255;
  s.glossiness:=10;
  s.alpha:=255;
  s.TexFileName:='None';
  s.NormalMapFileName:='None';
  s.SpecularMapFileName:='None';
  result:=s;
  end;
  Exit;
 end;
end;
{------------------------------------------------------------------}
procedure  GetModelGeometry(ModelIdent, Frame : integer; GeometryData : PMeshGeometry); stdcall;
var i,j : integer;
begin
if MeshsCount<>0 then
for i:=0 to MeshsCount-1 do
 if Meshs[i].Ident=ModelIdent then
 with GeometryData^ do
 begin

   VerticesCount:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).VertexCount;
   FacesCount:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).FacesCount;

   SetLength(Vertices,VerticesCount);
   SetLength(Normals,VerticesCount);
   SetLength(TextureVertices,VerticesCount);
   SetLength(Tangents,length(TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Tangent));

   for j := 0 to VerticesCount - 1 do
    begin

    Vertices[j]:=vertex(TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Vertices[j].x,TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Vertices[j].y,TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Vertices[j].z);

    case Meshs[i].Mesh.ScaleType of
    1:
    begin
      Vertices[j].X:=Vertices[j].X*TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).fExtent;
      Vertices[j].Y:=Vertices[j].Y*TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).fExtent;
      Vertices[j].Z:=Vertices[j].Z*TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).fExtent;
    end;
    2:
    begin
      Vertices[j].X:=Vertices[j].X*TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).fExtentX;
      Vertices[j].Y:=Vertices[j].Y*TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).fExtentY;
      Vertices[j].Z:=Vertices[j].Z*TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).fExtentZ;
    end;
    3:
    begin
      Vertices[j].X:=Vertices[j].X*Meshs[i].Mesh.fAllScale;
      Vertices[j].Y:=Vertices[j].Y*Meshs[i].Mesh.fAllScale;
      Vertices[j].Z:=Vertices[j].Z*Meshs[i].Mesh.fAllScale;
    end;
    end;

     Normals[j]:=vertex(TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).SmoothNormals[j].x,TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).SmoothNormals[j].y,TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).SmoothNormals[j].z);
     TextureVertices[j]:=vertex(Meshs[i].Mesh.TexVertices[j].x,Meshs[i].Mesh.TexVertices[j].y,Meshs[i].Mesh.TexVertices[j].z);

     if length(Tangents)>0 then
     Tangents[j]:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Tangent[j];

    end;

   SetLength(Faces,FacesCount);
   if Meshs[i].Mesh.TexturePresent then
   SetLength(TextureFaces,FacesCount) else
   SetLength(TextureFaces,0);

   for j := 0 to VerticesCount - 1 do
    begin
     Faces[j][0]:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Faces[j][0];
     Faces[j][1]:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Faces[j][1];
     Faces[j][2]:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Faces[j][2];
     if Meshs[i].Mesh.TexturePresent then
     begin
     TextureFaces[j][0]:=Meshs[i].Mesh.TexFaces[j][0];
     TextureFaces[j][1]:=Meshs[i].Mesh.TexFaces[j][1];
     TextureFaces[j][2]:=Meshs[i].Mesh.TexFaces[j][2];
     end;
    end;

  Exit;
 end;
end;
{------------------------------------------------------------------}
function ModelTrianglesCount(Modelident,Frame : integer) : Cardinal; stdcall;
var i : integer;
begin
result:=0;
if MeshsCount<>0 then
for i:=0 to MeshsCount-1 do
 if Meshs[i].Ident=ModelIdent then
 begin
  result:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).FacesCount;
  Exit;
 end;
end;
{------------------------------------------------------------------}
function ModelBoundingBox(Modelident,Frame : integer):TVertex; stdcall;
var i : integer;
begin
if MeshsCount<>0 then
for i:=0 to MeshsCount-1 do
 if Meshs[i].Ident=ModelIdent then
 begin

    if Frame>Meshs[i].Mesh.Meshes.Count-1 then Frame:=0;
    case Meshs[i].Mesh.ScaleType of
    1:begin
    result.x:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Width*TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).fExtent;
    result.y:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Height*TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).fExtent;
    result.z:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Depth*TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).fExtent;
    end;
    2:begin
    result.x:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Width*TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).fExtentX;
    result.y:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Height*TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).fExtentY;
    result.z:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Depth*TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).fExtentZ;
    end;
    3:begin
    result.x:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Width*Meshs[i].Mesh.fAllScale;
    result.y:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Height*Meshs[i].Mesh.fAllScale;
    result.z:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Depth*Meshs[i].Mesh.fAllScale;
    end;
    else
    begin
    result.x:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Width;
    result.y:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Height;
    result.z:=TGLMesh(Meshs[i].Mesh.Meshes.Items[Frame]).Depth;
    end;
    end;//case

 Exit;
 end;

end;
{------------------------------------------------------------------}
function ModelFramesCount(Modelident : integer):Integer; stdcall;
var i : integer;
begin
result:=0;
if MeshsCount<>0 then
for i:=0 to MeshsCount-1 do
 if Meshs[i].Ident=ModelIdent then
 begin
 result:=Meshs[i].Mesh.Meshes.Count;
 Exit;
 end;
end;
{------------------------------------------------------------------}
function LoadModel(Filename : string; ScaleType : byte; NormalInv : boolean) : integer; stdcall;
begin
 if fileexists(Filename) then
 begin
 inc(OverAllMeshUsed);

 SetLength(Meshs,MeshsCount+1);
 result:=OverAllMeshUsed;

 try
 Meshs[MeshsCount].Ident:=OverAllMeshUsed;
 Meshs[MeshsCount].Mesh:=TGLMultyMesh.Create;
 Meshs[MeshsCount].Mesh.LoadFromFile(Filename,NormalInv);
 Meshs[MeshsCount].Mesh.ScaleType := ScaleType;
 Meshs[MeshsCount].Mesh.fSmooth:= false;
 inc(MeshsCount);
 except
 //AddToLogFile(EngineLog,'Model "'+ Filename +'" not loaded. May be file corrupted or wrong file.');
 result:=0;
 Exit;
 end;
 //AddToLogFile(EngineLog,'Model "'+ Filename +'" loaded successfully.');
 end else
 begin
 //AddToLogFile(EngineLog,'Model file "'+ Filename +'" not found!');
 //MessageBox(0, PChar('Model file "'+ Filename +'" not found!'), PChar('Draw3D Unit'), MB_OK or MB_ICONERROR);
 result:=0;
 end;
end;
{------------------------------------------------------------------}
procedure DrawModel(ModelIdent, Frame : integer; Smooth : boolean); stdcall;
var i : cardinal;
begin
if MeshsCount<>0 then
for i:=0 to MeshsCount-1 do
 if Meshs[i].Ident=ModelIdent then
 begin
 Meshs[i].Mesh.fSmooth:=Smooth;
 if (Meshs[i].Mesh.Meshes.Count>1) and (Frame<Meshs[i].Mesh.Meshes.Count) and
 (Frame>0) then
 Meshs[i].Mesh.CurrentFrame:=Frame else Meshs[i].Mesh.CurrentFrame:=0;
 Meshs[i].Mesh.Draw;
 Exit;
 end;
end;
{------------------------------------------------------------------}
procedure FreeModel(ModelIdent : integer); stdcall;
var i : cardinal;
T : TAMesh;
begin
for i:=0 to MeshsCount-1 do
 if Meshs[i].Ident=ModelIdent then
 begin

 Meshs[i].Mesh.Free;

 if MeshsCount>1 then
 begin
 T:=Meshs[MeshsCount-1];
 Meshs[i]:=T;
 end;

 SetLength(Meshs,MeshsCount-1);
 dec(MeshsCount);

 Exit;
 end;
end;
{Other 3D routines-------------------------------------------------------------}
procedure BeginObj3D; stdcall;
begin
   InBlock:=true;
   SetLength(Obj3DInfo,length(Obj3DInfo)+1);
   Obj3DInfo[length(Obj3DInfo)-1].Texture:=curTexture;
   Obj3DInfo[length(Obj3DInfo)-1].Projecting:=Projecting;
   glGetFloatv(GL_CURRENT_COLOR, @Obj3DInfo[length(Obj3DInfo)-1].Color);

  if Projecting then
  glEnable(GL_BLEND);

  glPushMatrix();
end;
{------------------------------------------------------------------}
procedure EndObj3D; stdcall;
begin
  glPopMatrix();
  glcolor4f(Obj3DInfo[length(Obj3DInfo)-1].Color[1],Obj3DInfo[length(Obj3DInfo)-1].Color[2],Obj3DInfo[length(Obj3DInfo)-1].Color[3],Obj3DInfo[length(Obj3DInfo)-1].Color[4]);
  SetTexture(Obj3DInfo[length(Obj3DInfo)-1].Texture);
  Projecting:=Obj3DInfo[length(Obj3DInfo)-1].Projecting;
  SetLength(Obj3DInfo,length(Obj3DInfo)-1);
  if not Projecting then
  begin
  glDisable(GL_TEXTURE_GEN_S);
  glDisable(GL_TEXTURE_GEN_T);
  end;
  glDisable(GL_BLEND);
  InBlock:=false;
end;
{------------------------------------------------------------------}
procedure CalculateFrustum; stdcall;
begin
_frustumcalculated:=true;
Frustum.Calculate;
end;
{------------------------------------------------------------------}
function IsPointInFrustum(X,Y,Z : single) : boolean; stdcall;
begin
result:=Frustum.IsPointWithin(X,Y,Z);
end;
{------------------------------------------------------------------}
function IsSphereInFrustum(X,Y,Z,Radius : single) : boolean; stdcall;
begin
result:=Frustum.IsSphereWithin(X,Y,Z,Radius);
end;
{------------------------------------------------------------------}
function IsBoxInFrustum(X,Y,Z,W,H,D : single) : boolean; stdcall;
begin
result:=Frustum.IsBoxWithin(X,Y,Z,W,H,D);
end;
{------------------------------------------------------------------}
procedure SetMultytexturingLayerOffset(Layer : cardinal; X,Y : single); stdcall;
begin
 MultyCoordOffset[Layer][0]:=X;
 MultyCoordOffset[Layer][1]:=Y;
end;
{------------------------------------------------------------------}
procedure SetMultytexturingLayerTexCoordMulti(Layer : cardinal; X,Y : single); stdcall;
begin
 MultyCoordOffset[Layer][2]:=X;
 MultyCoordOffset[Layer][3]:=Y;
end;
{------------------------------------------------------------------}
procedure DrawPolygon3D(points : array of TVertex3D); stdcall;
var i : integer;
begin
 glBegin(GL_POLYGON);
  for i:=0 to Length(points)-1 do
   begin
   glcolor4ub(GetRValue(points[i].Color),GetGValue(points[i].Color),GetBValue(points[i].Color),points[i].Alpha);
   _glTexCoord2f(points[i].TexX,points[i].TexY);
   glVertex3f(points[i].X,points[i].Y,points[i].Z);
   end;
 glEnd;
end;
{------------------------------------------------------------------}
function CreateTextureToRenderIn(TextureWidth,TextureHeight : integer):GlUint; stdcall;
begin
  result:=CreateRenderTex(TextureWidth,TextureHeight);
end;
{------------------------------------------------------------------}
procedure SetCamera(Camera : TCamera); stdcall;
var
  converted: Int64;
  low, high: Cardinal;
begin
end;
{------------------------------------------------------------------}
procedure ClearZBuffer; stdcall;
begin
glClear(GL_DEPTH_BUFFER_BIT);
end;
{------------------------------------------------------------------}
procedure ZBuffer(Active : boolean); stdcall;
begin
if Active then glEnable(GL_DEPTH_TEST) else glDisable(GL_DEPTH_TEST);
end;
{------------------------------------------------------------------}
procedure ResetMatrix; stdcall;
begin
glLoadIdentity();
end;
{------------------------------------------------------------------}
procedure SetFog(Color : Integer; Fog_Start, Fog_End : single); stdcall;
var fogColor : Array [0..3] of GLFloat;
begin
 fogColor[0]:=GetRValue(Color)/255;
 fogColor[1]:=GetGValue(Color)/255;
 fogColor[2]:=GetBValue(Color)/255;
 fogColor[3]:=1.0;
 glEnable(GL_FOG);
 glFogi  (GL_FOG_MODE, GL_LINEAR);
 glHint  (GL_FOG_HINT, GL_DONT_CARE);
 glFogf  (GL_FOG_START, Fog_Start);
 glFogf  (GL_FOG_END, Fog_End);
 glFogfv (GL_FOG_COLOR, @fogColor);
end;
{------------------------------------------------------------------}
procedure DeactiveFog; stdcall;
begin
 glDisable(GL_FOG);
end;
{------------------------------------------------------------------}
procedure DrawCylinder(Radius,Height : single); stdcall;
begin
  gluCylinder(QuadraticObject, Radius, Radius, Height, 24, 1);
  gluQuadricOrientation(QuadraticObject, GLU_INSIDE);
  gluDisk(QuadraticObject, 0, Radius, 24, 1);
  gluQuadricOrientation(QuadraticObject, GLU_OUTSIDE);
  glTranslatef(0, 0, Height);
  gluDisk(QuadraticObject, 0, Radius, 24, 1);
end;
{------------------------------------------------------------------}
procedure DrawSphere(Radius : single); stdcall;
begin
glPushMatrix();
glScalef(Radius,Radius,Radius);
glCallList(SphereDL);
glPopMatrix();
end;


{------------------------------------------------------------------}
procedure DrawEllipse(Width,Height,Depth : single); stdcall;
begin
glPushMatrix();
glScalef(Width,Height,Depth);
glCallList(SphereDL);
glPopMatrix();
end;
{------------------------------------------------------------------}
procedure DrawPlane(Width,Height : single); stdcall;
begin
glBegin(GL_QUADS);
 glNormal3f( 0.0, 0.0, 1.0);
 _glTexCoord2f(0,1);
 glVertex2f(-Width/2,-Height/2);
 _glTexCoord2f(1,1);
 glVertex2f(Width/2, -Height/2);
 _glTexCoord2f(1,0);
 glVertex2f(Width/2,  Height/2);
 _glTexCoord2f(0,0);
 glVertex2f(-Width/2, Height/2);
glEnd;
end;
{------------------------------------------------------------------}
procedure DrawSprite(Width,Height : single; FramesXCount, FramesYCount, FrameNumber: integer);stdcall;
var imgWidth, imgHeight : glfloat; XFrame, YFrame : byte;
begin
  if FramesXCount=0 then FramesXCount:=1;
  if FramesYCount=0 then FramesYCount:=1;

  imgWidth:=1.0/FramesXCount;
  imgHeight:=1.0/FramesYCount;

  YFrame:=(FrameNumber div FramesXCount)+1;
  if FrameNumber mod FramesXCount = 0 then YFrame:=YFrame-1;
  XFrame:=FrameNumber - (YFrame-1)*FramesXCount;

  XFrame:=XFrame-1;
  YFrame:=YFrame-1;

      glBegin(GL_QUADS);
        glNormal3f( 0.0, 0.0, 1.0);
        _glTexCoord2f(imgWidth*XFrame, imgHeight*YFrame);
        glVertex2f(-Width/2,-Height/2);

        _glTexCoord2f(imgWidth*XFrame+imgWidth, imgHeight*YFrame);
        glVertex2f(Width/2, -Height/2);

        _glTexCoord2f(imgWidth*XFrame+imgWidth, imgHeight*YFrame+imgHeight);
        glVertex2f( Width/2,  Height/2);

        _glTexCoord2f(imgWidth*XFrame, imgHeight*YFrame+imgHeight);
        glVertex2f(-Width/2,  Height/2);
      glEnd;

end;
{------------------------------------------------------------------}
procedure DrawSprite_BillBoard(Width,Height : single; FramesXCount, FramesYCount, FrameNumber: integer);stdcall;
var imgWidth, imgHeight : glfloat; XFrame, YFrame : byte;
m : TGLMatrixd4;
v : array [0..3] of TVertex;
length : single;
begin
  if FramesXCount=0 then FramesXCount:=1;
  if FramesYCount=0 then FramesYCount:=1;

  imgWidth:=1.0/FramesXCount;
  imgHeight:=1.0/FramesYCount;

  YFrame:=(FrameNumber div FramesXCount)+1;
  if FrameNumber mod FramesXCount = 0 then YFrame:=YFrame-1;
  XFrame:=FrameNumber - (YFrame-1)*FramesXCount;

  XFrame:=XFrame-1;
  YFrame:=YFrame-1;

  glGetDoublev(GL_MODELVIEW_MATRIX, @m );

  Width:=Width/1.41;
  Height:=Height/1.41;

  v[0].X:=-m[0][0]-m[0][1];
  v[0].Y:=-m[1][0]-m[1][1];
  v[0].Z:=-m[2][0]-m[2][1];

  length:=sqrt(sqr(v[0].X) + sqr(v[0].Y) + sqr(v[0].Z));
  v[0].X:=v[0].X/length*Width;
  v[0].Y:=v[0].Y/length*Height;
  v[0].Z:=v[0].Z/length*Width;

  v[1].X:=m[0][0]-m[0][1];
  v[1].Y:=m[1][0]-m[1][1];
  v[1].Z:=m[2][0]-m[2][1];

  length:=sqrt(sqr(v[1].X) + sqr(v[1].Y) + sqr(v[1].Z));
  v[1].X:=v[1].X/length*Width;
  v[1].Y:=v[1].Y/length*Height;
  v[1].Z:=v[1].Z/length*Width;

  v[2].X:=m[0][0]+m[0][1];
  v[2].Y:=m[1][0]+m[1][1];
  v[2].Z:=m[2][0]+m[2][1];

  length:=sqrt(sqr(v[2].X) + sqr(v[2].Y) + sqr(v[2].Z));
  v[2].X:=v[2].X/length*Width;
  v[2].Y:=v[2].Y/length*Height;
  v[2].Z:=v[2].Z/length*Width;

  v[3].X:=-m[0][0]+m[0][1];
  v[3].Y:=-m[1][0]+m[1][1];
  v[3].Z:=-m[2][0]+m[2][1];

  length:=sqrt(sqr(v[3].X) + sqr(v[3].Y) + sqr(v[3].Z));
  v[3].X:=v[3].X/length*Width;
  v[3].Y:=v[3].Y/length*Height;
  v[3].Z:=v[3].Z/length*Width;

      glBegin(GL_QUADS);
        glNormal3f( 0.0, 0.0, 1.0);
        _glTexCoord2f(imgWidth*XFrame, imgHeight*YFrame);
        glVertex3fv(@v[0]);

        _glTexCoord2f(imgWidth*XFrame+imgWidth, imgHeight*YFrame);
        glVertex3fv(@v[1]);

        _glTexCoord2f(imgWidth*XFrame+imgWidth, imgHeight*YFrame+imgHeight);
        glVertex3fv(@v[2]);

        _glTexCoord2f(imgWidth*XFrame, imgHeight*YFrame+imgHeight);
        glVertex3fv(@v[3]);
      glEnd;

end;
{------------------------------------------------------------------}
procedure DrawTextureToTexture(TexSource,TexTarget : GluInt; X,Y : integer); stdcall;
var
pBits : pByteArray;
begin
GetMem(pBits,GetTextureInfo(TexSource).Width*GetTextureInfo(TexSource).Height*3);
glBindTexture(GL_TEXTURE_2D, TexSource);
glGetTexImage(GL_TEXTURE_2D,0,GL_RGB,GL_UNSIGNED_BYTE,pBits);
glBindTexture(GL_TEXTURE_2D, TexTarget);
glTexParameterf(GL_TEXTURE_2D, GL_GENERATE_MIPMAP_SGIS, 0);
glTexSubImage2D(GL_TEXTURE_2D,0,X,Y,GetTextureInfo(TexSource).Width,GetTextureInfo(TexSource).Height,GL_RGB,GL_UNSIGNED_BYTE,pBits);
glBindTexture(GL_TEXTURE_2D, 0);
FreeMem(pBits);
end;
{------------------------------------------------------------------}
procedure RenderTexToTexFBO(ToTexture,TexSource,TexTarget : GluInt; X,Y : integer); stdcall;
var
w, h, w1, h1 : cardinal;
begin
if GL_EXT_framebuffer_object and _UseFBO then
begin
w:=GetTextureInfo(TexTarget).Width;
h:=GetTextureInfo(TexTarget).Height;

w1:=GetTextureInfo(TexSource).Width;
h1:=GetTextureInfo(TexSource).Height;

if (GetTextureInfo(ToTexture).Width<>w) or (GetTextureInfo(ToTexture).Height<>h) then Exit;

glPushMatrix();
glViewport(0, 0, w, h);
glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo2);
glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, ToTexture, 0);
if glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT) <> GL_FRAMEBUFFER_COMPLETE_EXT then
begin
glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
DrawTextureToTexture(TexSource,TexTarget,x,y);
DrawTextureToTexture(TexTarget,ToTexture,0,0);
AddToLogFile(EngineLog,'Faild to "RenderTexToTexFBO". Error in FBO initialization.');
Exit;
end;
glLoadIdentity();
glClear(GL_COLOR_BUFFER_BIT);
glMatrixMode(GL_PROJECTION);
glPushMatrix;
glLoadIdentity;
gluOrtho2D(0,w,0,h);
glMatrixMode(GL_MODELVIEW);
glPushMatrix;
glLoadIdentity;

glEnable(GL_ALPHA_TEST);
glAlphaFunc(GL_GREATER, 0.1);

glBindTexture(GL_TEXTURE_2D,TexTarget);

  glBegin(GL_QUADS);
    glTexCoord2f(0,0);
    glVertex2f(0,0);
    glTexCoord2f(1,0);
    glVertex2f(w,0);
    glTexCoord2f(1,1);
    glVertex2f(w,h);
    glTexCoord2f(0,1);
    glVertex2f(0,h);
   glEnd;

if TexSource<>0 then
begin
glBindTexture(GL_TEXTURE_2D,TexSource);

  glBegin(GL_QUADS);
    glTexCoord2f(0,0);
    glVertex2f(X,Y);
    glTexCoord2f(1,0);
    glVertex2f(X+W1,Y);
    glTexCoord2f(1,1);
    glVertex2f(X+W1,Y+H1);
    glTexCoord2f(0,1);
    glVertex2f(X,Y+H1);
   glEnd;
end;

glBindTexture(GL_TEXTURE_2D,0);
glDisable(GL_ALPHA_TEST);

glPopMatrix;
glMatrixMode(GL_PROJECTION);
glPopMatrix;
glMatrixMode(GL_MODELVIEW);
glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, 0, 0);
glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
glViewport(0, 0, CurW, CurH);
glPopMatrix();
glBindTexture(GL_TEXTURE_2D, 0);
glClear(GL_COLOR_BUFFER_BIT);
end;
end;
{------------------------------------------------------------------}
procedure DrawTextureToTextureTransparentColor(TexSource,TexTarget : GluInt; X,Y : integer; Color : Cardinal); stdcall;
type
TRGB = record
  R, G, B : Byte;
 end;
var c : TRGB;
pBits : pByteArray;
i,line : integer;
w, h : cardinal;
begin
w:=GetTextureInfo(TexSource).Width;
h:=GetTextureInfo(TexSource).Height;
GetMem(pBits,w*h*3);
glBindTexture(GL_TEXTURE_2D, TexSource);
glGetTexImage(GL_TEXTURE_2D,0,GL_RGB,GL_UNSIGNED_BYTE,pBits);
glBindTexture(GL_TEXTURE_2D, TexTarget);
glTexParameterf(GL_TEXTURE_2D, GL_GENERATE_MIPMAP_SGIS, 0);
line:=0;
for i:=0 to ((w*h*3) div 3)-1 do
 if not ((pBits[i*3]=GetRvalue(Color)) and (pBits[i*3+1]=GetGvalue(Color)) and (pBits[i*3+2]=GetBvalue(Color))) then
 begin
 if i-w*line > w then line:=line+1;
 c.R:=pBits[i*3];
 c.G:=pBits[i*3+1];
 c.B:=pBits[i*3+2];
 glTexSubImage2D(GL_TEXTURE_2D,0,X+(i-line*w),Y+line,1,1,GL_RGB,GL_UNSIGNED_BYTE,@c);
 end;
glBindTexture(GL_TEXTURE_2D, 0);
FreeMem(pBits);
end;
{------------------------------------------------------------------}
procedure DeactiveLight(ID : integer); stdcall;
var i : integer;
begin
if ID = -1 then
 begin
   for i:=0 to 20 do
   begin
    LightsOn[i]:=False;
    glDisable(GETLIGHT(i));
   end;
  glDisable(GL_LIGHTING);
 end else
 begin
  glDisable(GETLIGHT(ID));
  LightsOn[ID]:=FALSE;
 end;
end;
{------------------------------------------------------------------}
procedure SetLight(ID : integer; X,Y,Z : single; LightColor : integer; Radius : single; Visualize : boolean; Scale : single); stdcall;
var
Color : Array [1..4] of GLFloat;
LightPos : Array [0..3] of GLfloat;
begin

if (ID = -1) or (ID>GL_MAX_LIGHTS) then Exit;

  LightPos[0]:=X;
  LightPos[1]:=Y;
  LightPos[2]:=Z;
  LightPos[3]:=1;

  glLightfv(GETLIGHT(ID), GL_POSITION, @LightPos);

  light_diffuse[0]:=GetRValue(LightColor)/255;
  light_diffuse[1]:=GetGValue(LightColor)/255;
  light_diffuse[2]:=GetBValue(LightColor)/255;
  light_diffuse[3]:=1.0;

  light_specular[0]:=GetRValue(LightColor)/255;
  light_specular[1]:=GetGValue(LightColor)/255;
  light_specular[2]:=GetBValue(LightColor)/255;
  light_specular[3]:=1.0;

  glMaterialfv(GL_FRONT,  GL_SPECULAR, @mat_specular);

  glLightfv(GETLIGHT(ID), GL_AMBIENT,  @light_ambient);
  glLightfv(GETLIGHT(ID), GL_DIFFUSE,  @light_diffuse);
  glLightfv(GETLIGHT(ID), GL_SPECULAR, @light_specular);

  if radius<0 then
  begin
  glLightf(GETLIGHT(ID), GL_CONSTANT_ATTENUATION, 1.0);
  glLightf(GETLIGHT(ID), GL_LINEAR_ATTENUATION, 0);
  end else
  begin
  glLightf(GETLIGHT(ID), GL_CONSTANT_ATTENUATION, 0);
  glLightf(GETLIGHT(ID), GL_LINEAR_ATTENUATION, 10/radius);
  end;

if Visualize then
 begin
  glGetFloatv(GL_CURRENT_COLOR, @Color);
   glDisable(GL_LIGHTING);
   glDisable(GL_TEXTURE_2D);
   glPointSize(Scale);
   glBegin(GL_POINTS);
   glColor3f(light_diffuse[0],light_diffuse[1],light_diffuse[2]);
   glVertex3f(X,Y,Z);
   glEnd();
   glPointSize(1.0);
   glEnable(GL_TEXTURE_2D);
  glcolor4f(Color[1],Color[2],Color[3],Color[4]);
 end;

  glEnable(GL_LIGHTING);
  glEnable(GETLIGHT(ID));
  LightsOn[ID]:=TRUE;
end;
{------------------------------------------------------------------}
procedure Position3D(X,Y,Z : single); stdcall;
begin
if not In2DWeAre then
glTranslatef(x,y,z);
end;
{------------------------------------------------------------------}
procedure Scale3D(Scale : single); stdcall;
begin
glScalef(Scale,Scale,Scale);
end;
{------------------------------------------------------------------}
procedure SetTexture(Texture : gluint); stdcall;
begin
if not Projecting then
begin
 if not InBlock then CurTexture:=Texture;
 glBindTexture(GL_TEXTURE_2D, Texture);
end;
end;
{------------------------------------------------------------------}
procedure ActivateMultitexturingLayer(Layer : Cardinal); stdcall;
begin
 if GL_ARB_multitexture then
 begin
 glActiveTextureARB(GL_TEXTURE0_ARB+Layer);
 glEnable(GL_TEXTURE_2D);
 MultyTexActive:=true;
 end;
end;
{------------------------------------------------------------------}
procedure DeactiveMultytexturing; stdcall;
var i : integer;
begin
 if GL_ARB_multitexture then
 begin
  for i:=0 to 5 do
   begin
   glActiveTextureARB(GL_TEXTURE0_ARB+i);
   if i<>0 then
   glDisable(GL_TEXTURE_2D);
   SetTexture(0);
   end;
   glActiveTextureARB(GL_TEXTURE0_ARB);
 end;
end;
{------------------------------------------------------------------}
procedure Position2D(X,Y : integer); stdcall;
begin
if In2DWeAre then
glTranslatef((4.42/InitResX)*X,-(3.314/InitResY)*Y,0.0);
end;
{------------------------------------------------------------------}
procedure Color3D(Color:integer; Alpha : byte; Diffuse : boolean; MaterialShininess : single); stdcall;
begin
mat_shininess:=MaterialShininess;
glMaterialfv(GL_FRONT, GL_SHININESS, @mat_shininess);

 if Alpha<>255 then
 begin
 GlEnable(GL_Blend);

 if not Projecting then
   if not Diffuse then
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
      else
        glBlendFunc(GL_SRC_ALPHA, GL_ONE);

 end;

 if Alpha=254 then Alpha:=255;

glcolor4ub(GetRValue(Color),GetGValue(Color),GetBValue(Color),Alpha);

end;
{------------------------------------------------------------------}
procedure AdductingMatrix3Dto2D; stdcall;
begin
  glPushMatrix;
  glLoadIdentity;
  glTranslatef(-2.210,1.657,-4.000);
  In2DWeAre:=TRUE;
    //on screen matrix width  4.42
    //                 height 3.314
end;
{------------------------------------------------------------------}
procedure ReturnStandartMatrix3D; stdcall;
begin
  glPopMatrix;
  In2DWeAre:=FALSE;
end;
{------------------------------------------------------------------}
procedure RotateX(Angle : single); stdcall;
begin
glRotatef(Angle,-1,0,0);
end;
{------------------------------------------------------------------}
procedure RotateY(Angle : single); stdcall;
begin
glRotatef(Angle,0,-1,0);
end;
{------------------------------------------------------------------}
procedure RotateZ(Angle : single); stdcall;
begin
glRotatef(Angle,0,0,-1);
end;
{------------------------------------------------------------------}
procedure DrawLine(X,Y,Z,X1,Y1,Z1 : single; LineWidth : real = 1.0; Smooth : boolean = true); stdcall;
begin
 if Smooth then
  begin
  glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
  glEnable(GL_LINE_SMOOTH);
  glEnable(GL_BLEND);
  end;
 glLineWidth(LineWidth);
  glBegin(GL_LINES);
    glVertex3f(X,Y,Z);
    glVertex3f(X1,Y1,Z1);
  glEnd;
 if Smooth then
  begin
  glDisable(GL_LINE_SMOOTH);
  glDisable(GL_BLEND);
  end;
end;
{------------------------------------------------------------------}
procedure DrawPoint(X,Y,Z : single); stdcall;
begin
 glBegin(GL_POINTS);
    glVertex3f(X,Y,Z);
 glEnd;
end;
{------------------------------------------------------------------}
procedure EnableSphereMapping; stdcall;
begin
  glTexGenf(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
  glTexGenf(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
  glEnable(GL_TEXTURE_GEN_S);
  glEnable(GL_TEXTURE_GEN_T);
end;
{------------------------------------------------------------------}
procedure DisableSphereMapping; stdcall;
begin
 glDisable(GL_TEXTURE_GEN_S);
 glDisable(GL_TEXTURE_GEN_T);
end;
{------------------------------------------------------------------}
procedure StartRenderToTexture(Texture : GlUint); stdcall;
var
b : BYTEBOOL;
mode : Integer;
begin

  RenderTTWidth:=GetTextureInfo(Texture).Width;
  RenderTTHeight:=GetTextureInfo(Texture).Height;
  RenderedTex:=Texture;

glPushMatrix();

  glViewport(0, 0, RenderTTWidth, RenderTTHeight);

  if GetTextureInfo(Texture).FileType=5 then
  begin
  glDisable(GL_TEXTURE_2D);
  glDisable(GL_LIGHTING);
  glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
  glGetBooleanv(GL_CULL_FACE,@b);
  glGetIntegerv(GL_CULL_FACE_MODE,@mode);
  if b and (mode=GL_FRONT) then
  //glPolygonOffset(4.5, 3.25)
  glPolygonOffset(0.5, 0.25)
  else
  glPolygonOffset(5, 4);
  glEnable(GL_POLYGON_OFFSET_FILL);

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity;
  gluPerspective(ShadowRenderAngle, RenderTTWidth/RenderTTWidth, InitZNear, InitZFar);
  glMatrixMode(GL_MODELVIEW);
  end;


  if GL_EXT_framebuffer_object and _UseFBO then
  begin
   InitFBO(RenderTTWidth,RenderTTHeight,InitZBuffer);
   glBindTexture(GL_TEXTURE_2D, 0);
   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo_frame);
    if GetTextureInfo(RenderedTex).FileType=5 then
    begin
    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_TEXTURE_2D, RenderedTex, 0);
    glDrawBuffer(GL_NONE);
    end else
    begin
    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, RenderedTex, 0);
    glDrawBuffer(GL_FRONT);
    end;
   CantRenderInFBO:=false;
   if glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT) <> GL_FRAMEBUFFER_COMPLETE_EXT then
   begin
   CantRenderInFBO:=true;
   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
   end;

  end;

 glLoadIdentity();
 if GetTextureInfo(RenderedTex).FileType=5 then
 glClear(GL_DEPTH_BUFFER_BIT)
 else
 glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);

end;
{------------------------------------------------------------------}
procedure EndRenderToTexture; stdcall;
var i : integer;
begin


   if GL_EXT_framebuffer_object and _UseFBO and not CantRenderInFBO then
   begin
   if GetTextureInfo(RenderedTex).FileType=5 then
   glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_TEXTURE_2D, 0, 0)
   else
   glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, 0, 0);
   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
   end else
   begin
   glBindTexture(GL_TEXTURE_2D, RenderedTex);
   if GetTextureInfo(RenderedTex).FileType=5 then
   glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, 0, 0, RenderTTWidth, RenderTTHeight, 0)
   else
   glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 0, 0, RenderTTWidth, RenderTTHeight, 0);
   end;

   glViewport(0, 0, CurW, CurH);


   if GetTextureInfo(RenderedTex).FileType=5 then
   begin
    for i:=0 to 20 do
      if LightsOn[i] then glEnable(GL_LIGHTING);
   glEnable(GL_TEXTURE_2D);
   glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
   glDisable(GL_POLYGON_OFFSET_FILL);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity;
   gluPerspective(initAngle, CurW/CurH, InitZNear, InitZFar);
   glMatrixMode(GL_MODELVIEW);
   end;

glPopMatrix();
glBindTexture(GL_TEXTURE_2D, 0);
if GetTextureInfo(RenderedTex).FileType=5 then
glClear(GL_DEPTH_BUFFER_BIT)
else
glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
end;
{------------------------------------------------------------------}
procedure DrawAxes(Length : single = 1.0); stdcall;
var
Color : Array [1..4] of GLFloat;
begin
 glGetFloatv(GL_CURRENT_COLOR, @Color);

glBegin (GL_LINES);
 glColor3f(1,0,0);
 glVertex3f(0,0,0);
 glVertex3f(Length,0,0);
 glColor3f(0,1,0);
 glVertex3f(0,0,0);
 glVertex3f(0,Length,0);
 glColor3f(0,0,1);
 glVertex3f(0,0,0);
 glVertex3f(0,0,Length);
glEnd;

 glcolor4f(Color[1],Color[2],Color[3],Color[4]);
end;

// Объявление внешней функции Write3D из DGLEngine.dll
procedure Write3D(FontID: Integer; Text: PChar); stdcall; external 'DGLEngine.dll';

function GetCurrentHour: Integer;
begin
  try
    Result := PInteger(Pointer($00400000 + $8C08034))^;
    // Ограничиваем значение от 0 до 23
    if Result < 0 then Result := 0;
    if Result > 23 then Result := Result mod 24;
  except
    Result := 12; // По умолчанию день
  end;
end;

function GetCurrentSeason: string;
begin
  try
    if PByte(Pointer($00400000 + $349968))^ = 1 then
      Result := 'ЗИМА'
    else
      Result := 'ЛЕТО';
  except
    Result := 'НЕИЗВЕСТНО';
  end;
end;

function IsNightTime: Boolean;
var
  hour: Integer;
  season: Byte;
begin
  hour := GetCurrentHour;
  
  try
    // Читаем сезон: 0 = лето, 1 = зима
    season := PByte(Pointer($00400000 + $349968))^;
    
    if season = 1 then
    begin
      // ЗИМА: ночь с 18:00 до 8:00
      Result := (hour >= 18) or (hour <= 7);
    end
    else
    begin
      // ЛЕТО: ночь с 21:00 до 5:00  
      Result := (hour >= 21) or (hour <= 4);
    end;
    
  except
    // При ошибке используем летнее время
    Result := (hour >= 21) or (hour <= 4);
  end;
end;

function FindTextureFileInFolder(folderPath: string): string;
var
  searchRec: TSearchRec;
  fileName: string;
begin
  Result := '';
  
  // Ищем файл, содержащий "254" и "395" в имени
  if FindFirst(folderPath + '\*254*395*.bmp', faAnyFile, searchRec) = 0 then
  begin
    Result := folderPath + '\' + searchRec.Name;
    FindClose(searchRec);
    Exit;
  end;
  FindClose(searchRec);
  
  // Если не найден точный, ищем любой файл с "254"
  if FindFirst(folderPath + '\*254*.bmp', faAnyFile, searchRec) = 0 then
  begin
    Result := folderPath + '\' + searchRec.Name;
    FindClose(searchRec);
    Exit;
  end;
  FindClose(searchRec);
  
  // Если не найден и такой, ищем любой файл с "395"
  if FindFirst(folderPath + '\*395*.bmp', faAnyFile, searchRec) = 0 then
  begin
    Result := folderPath + '\' + searchRec.Name;
    FindClose(searchRec);
  end;
  FindClose(searchRec);
end;

// Замените блок загрузки ночной klub текстуры в InitializeDayNightSystem:



procedure InitializeDayNightSystem;
var
  locFolder: string;
  directoryPath: string;
  dayFolderPath, nightFolderPath: string;
  cabDayPath, pultDayPath, day254Path, klubDayPath: string;
  cabNightPath, pultNightPath, night254Path, klubNightPath: string;
begin
  if DayNightInitialized then Exit;
  
  try
    // Определяем папку локомотива
    locFolder := GetLocomotiveFolder(GetLocomotiveTypeFromMemory);
    directoryPath := 'data\' + locFolder + '\' + LocNum + '\';
    
    AddToLogFile(EngineLog, '=== ДИАГНОСТИКА СИСТЕМЫ ДЕНЬ/НОЧЬ ===');
    AddToLogFile(EngineLog, 'LocNum: ' + LocNum);
    AddToLogFile(EngineLog, 'locFolder: ' + locFolder);
    AddToLogFile(EngineLog, 'directoryPath: ' + directoryPath);
    
    dayFolderPath := directoryPath;
    nightFolderPath := directoryPath + 'night';
    
    AddToLogFile(EngineLog, 'dayFolderPath: ' + dayFolderPath);
    AddToLogFile(EngineLog, 'nightFolderPath: ' + nightFolderPath);
    AddToLogFile(EngineLog, 'day folder exists: ' + BoolToStr(DirectoryExists(dayFolderPath), True));
    AddToLogFile(EngineLog, 'night folder exists: ' + BoolToStr(DirectoryExists(nightFolderPath), True));
    
    // Проверяем наличие папок day и night
    HasDayNightFolders := DirectoryExists(dayFolderPath) and DirectoryExists(nightFolderPath);
    
    if HasDayNightFolders then
    begin
      AddToLogFile(EngineLog, 'Найдены папки day/night, инициализируем систему смены текстур');
      
      // Формируем пути к файлам дня
      cabDayPath := dayFolderPath + '\cab.bmp';
      pultDayPath := dayFolderPath + '\pult.bmp';
      day254Path := FindTextureFileInFolder(dayFolderPath);
      klubDayPath := dayFolderPath + '\klub_bil.bmp';
      
      // Формируем пути к файлам ночи
      cabNightPath := nightFolderPath + '\cab.bmp';
      pultNightPath := nightFolderPath + '\pult.bmp';
      night254Path := FindTextureFileInFolder(nightFolderPath);
      klubNightPath := nightFolderPath + '\klub_bil.bmp';
      
      // === ДЕТАЛЬНАЯ ДИАГНОСТИКА KLUB ФАЙЛОВ ===
      AddToLogFile(EngineLog, '=== ДИАГНОСТИКА KLUB ФАЙЛОВ ===');
      AddToLogFile(EngineLog, 'klubDayPath: ' + klubDayPath);
      AddToLogFile(EngineLog, 'klubNightPath: ' + klubNightPath);
      AddToLogFile(EngineLog, 'Day klub file exists: ' + BoolToStr(FileExists(klubDayPath), True));
      AddToLogFile(EngineLog, 'Night klub file exists: ' + BoolToStr(FileExists(klubNightPath), True));
      
      // Проверяем размер файлов
      if FileExists(klubDayPath) then
      begin
        try
          //AddToLogFile(EngineLog, 'Day klub file size: ' + IntToStr(GetFileSize(klubDayPath)) + ' bytes');
        except
          AddToLogFile(EngineLog, 'Ошибка получения размера day klub файла');
        end;
      end;
      
      if FileExists(klubNightPath) then
      begin
        try
          //AddToLogFile(EngineLog, 'Night klub file size: ' + IntToStr(GetFileSize(klubNightPath)) + ' bytes');
        except
          AddToLogFile(EngineLog, 'Ошибка получения размера night klub файла');
        end;
      end;
      
      // Загружаем дневную klub текстуру
      if FileExists(klubDayPath) then
      begin
        try
          AddToLogFile(EngineLog, 'Попытка загрузки дневной klub текстуры...');
          DayKlubTextureID := LoadTextureFromFile(klubDayPath, 0, -1);
          if DayKlubTextureID > 0 then
            AddToLogFile(EngineLog, 'УСПЕШНО: Загружена дневная текстура klub: ' + IntToStr(DayKlubTextureID))
          else
            AddToLogFile(EngineLog, 'ОШИБКА: LoadTextureFromFile вернул 0 для дневной klub текстуры');
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'ИСКЛЮЧЕНИЕ при загрузке дневной klub текстуры: ' + E.Message);
        end;
      end
      else
      begin
        AddToLogFile(EngineLog, 'ФАЙЛ НЕ НАЙДЕН: ' + klubDayPath);
      end;

      // Загружаем ночную klub текстуру  
      if FileExists(klubNightPath) then
      begin
        try
          AddToLogFile(EngineLog, 'Попытка загрузки ночной klub текстуры...');
          NightKlubTextureID := LoadTextureFromFile(klubNightPath, 0, -1);
          if NightKlubTextureID > 0 then
            AddToLogFile(EngineLog, 'УСПЕШНО: Загружена ночная текстура klub: ' + IntToStr(NightKlubTextureID))
          else
            AddToLogFile(EngineLog, 'ОШИБКА: LoadTextureFromFile вернул 0 для ночной klub текстуры');
        except
          on E: Exception do
            AddToLogFile(EngineLog, 'ИСКЛЮЧЕНИЕ при загрузке ночной klub текстуры: ' + E.Message);
        end;
      end
      else
      begin
        AddToLogFile(EngineLog, 'ФАЙЛ НЕ НАЙДЕН: ' + klubNightPath);
      end;
      
      // Загружаем текстуры дня
      if FileExists(cabDayPath) then
      begin
        DayCabTextureID := LoadTextureFromFile(cabDayPath, 0, -1);
        AddToLogFile(EngineLog, 'Загружена дневная текстура cab: ' + IntToStr(DayCabTextureID));
      end;
      
      if FileExists(pultDayPath) then
      begin
        DayPultTextureID := LoadTextureFromFile(pultDayPath, 0, -1);
        AddToLogFile(EngineLog, 'Загружена дневная текстура pult: ' + IntToStr(DayPultTextureID));
      end;
      
      if day254Path <> '' then
      begin
        Day254TextureID := LoadTextureFromFile(day254Path, 0, -1);
        AddToLogFile(EngineLog, 'Загружена дневная текстура 254: ' + IntToStr(Day254TextureID));
      end;


      if FileExists(cabNightPath) then
      begin
        NightCabTextureID := LoadTextureFromFile(cabNightPath, 0, -1);
        AddToLogFile(EngineLog, 'Загружена ночная текстура cab: ' + IntToStr(NightCabTextureID));
      end;
      
      if FileExists(pultNightPath) then
      begin
        NightPultTextureID := LoadTextureFromFile(pultNightPath, 0, -1);
        AddToLogFile(EngineLog, 'Загружена ночная текстура pult: ' + IntToStr(NightPultTextureID));
      end;
      
      if night254Path <> '' then
      begin
        Night254TextureID := LoadTextureFromFile(night254Path, 0, -1);
        AddToLogFile(EngineLog, 'Загружена ночная текстура 254: ' + IntToStr(Night254TextureID));
      end;
      
      AddToLogFile(EngineLog, '=== ИТОГИ ИНИЦИАЛИЗАЦИИ ===');
      AddToLogFile(EngineLog, 'DayKlubTextureID: ' + IntToStr(DayKlubTextureID));
      AddToLogFile(EngineLog, 'NightKlubTextureID: ' + IntToStr(NightKlubTextureID));
      AddToLogFile(EngineLog, 'Система день/ночь инициализирована успешно');
    end
    else
    begin
      AddToLogFile(EngineLog, 'Папки day/night не найдены, система день/ночь отключена');
    end;
    
  except
    on E: Exception do
    begin
      AddToLogFile(EngineLog, 'КРИТИЧЕСКАЯ ОШИБКА инициализации системы день/ночь: ' + E.Message);
      HasDayNightFolders := False;
    end;
  end;
  
  DayNightInitialized := True;
end;

// Вспомогательная функция для получения размера файла:
function GetFileSize(const FileName: string): Int64;
var
  Handle: THandle;
  FindData: TWin32FindData;
begin
  Result := -1;
  Handle := FindFirstFile(PChar(FileName), FindData);
  if Handle <> INVALID_HANDLE_VALUE then
  begin
    Result := FindData.nFileSizeLow;
    Windows.FindClose(Handle);
  end;
end;


procedure ApplyDayNightTextures;
var
  isNight: Boolean;
  newTimeMode: Integer;
  textureAddr: Pointer;
  cabTextureID, pultTextureID, texture254ID, klubTextureID: Cardinal; // ← Добавили klubTextureID
  OldProtect: DWORD;
begin
  if not HasDayNightFolders then Exit;
  
  try
    // Определяем текущий режим времени
    isNight := IsNightTime;
    newTimeMode := Integer(isNight);
    
    // Если режим не изменился, выходим
    if newTimeMode = CurrentTimeMode then Exit;
    
    CurrentTimeMode := newTimeMode;
    CurrentIsNight := isNight;
    
    if isNight then
    begin
      AddToLogFile(EngineLog, 'Переключение на ночные текстуры (' + GetCurrentSeason + ', час: ' + IntToStr(GetCurrentHour) + ')');
      cabTextureID := NightCabTextureID;
      pultTextureID := NightPultTextureID;
      texture254ID := Night254TextureID;
      klubTextureID := NightKlubTextureID; // ← Добавили
    end
    else
    begin
      AddToLogFile(EngineLog, 'Переключение на дневные текстуры (' + GetCurrentSeason + ', час: ' + IntToStr(GetCurrentHour) + ')');
      cabTextureID := DayCabTextureID;
      pultTextureID := DayPultTextureID;
      texture254ID := Day254TextureID;
      klubTextureID := DayKlubTextureID; // ← Добавили
    end;
    
    // Применяем cab.bmp → pointer 91D427C [0x06]
    if cabTextureID > 0 then
    begin
      try
        textureAddr := Pointer(PCardinal(Pointer($91D427C))^ + $06);
        if VirtualProtect(textureAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
        begin
          PWord(textureAddr)^ := Word(cabTextureID);
          VirtualProtect(textureAddr, SizeOf(Word), OldProtect, OldProtect);
          AddToLogFile(EngineLog, 'Установлена cab текстура ID: ' + IntToStr(cabTextureID));
        end;
      except
        AddToLogFile(EngineLog, 'Ошибка установки cab текстуры');
      end;
    end;
    
    // Применяем pult.bmp → pointer 91D427C [0x08]
    if pultTextureID > 0 then
    begin
      try
        textureAddr := Pointer(PCardinal(Pointer($91D427C))^ + $08);
        if VirtualProtect(textureAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
        begin
          PWord(textureAddr)^ := Word(pultTextureID);
          VirtualProtect(textureAddr, SizeOf(Word), OldProtect, OldProtect);
          AddToLogFile(EngineLog, 'Установлена pult текстура ID: ' + IntToStr(pultTextureID));
        end;
      except
        AddToLogFile(EngineLog, 'Ошибка установки pult текстуры');
      end;
    end;
    
    // Применяем *254*395.bmp → pointer 9110D60 [0x38]
    if texture254ID > 0 then
    begin
      try
        textureAddr := Pointer(PCardinal(Pointer($9110D60))^ + $38);
        if VirtualProtect(textureAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
        begin
          PWord(textureAddr)^ := Word(texture254ID);
          VirtualProtect(textureAddr, SizeOf(Word), OldProtect, OldProtect);
          AddToLogFile(EngineLog, 'Установлена 254 текстура ID: ' + IntToStr(texture254ID));
        end;
      except
        AddToLogFile(EngineLog, 'Ошибка установки 254 текстуры');
      end;
    end;
    
    // ← НОВЫЙ БЛОК: Применяем klub_bil.bmp → pointer 9110D60 [0x34]
   if klubTextureID > 0 then
    begin
      try
        // Записываем по тому же адресу, что в LoadSettingsAndCustomModels
        textureAddr := Pointer(PCardinal(Pointer($9110D60))^ + $34);
        if VirtualProtect(textureAddr, SizeOf(Word), PAGE_EXECUTE_READWRITE, OldProtect) then
        begin
          PWord(textureAddr)^ := Word(klubTextureID);
          VirtualProtect(textureAddr, SizeOf(Word), OldProtect, OldProtect);
          AddToLogFile(EngineLog, 'Установлена klub текстура ID: ' + IntToStr(klubTextureID) + ' по адресу: ' + IntToHex(Cardinal(textureAddr), 8));
        end;
        
      except
        AddToLogFile(EngineLog, 'Ошибка установки klub текстуры');
      end;
    end;
    
  except
    on E: Exception do
      AddToLogFile(EngineLog, 'Ошибка применения текстур день/ночь: ' + E.Message);
  end;
end;



// Замените ProcessDayNightSystem на эту версию с диагностикой:

procedure ProcessDayNightSystem;
var
  currentTime: Cardinal;
begin
  currentTime := timeGetTime;
  
  // Проверяем время только по таймеру
  if (currentTime - LastTimeCheck) > TimeCheckInterval1 then
  begin
    AddToLogFile(EngineLog, '=== ProcessDayNightSystem ВЫЗВАНА ===');
    AddToLogFile(EngineLog, 'DayNightInitialized: ' + BoolToStr(DayNightInitialized, True));
    
    // Инициализируем систему при первом запуске
    if not DayNightInitialized then
    begin
      AddToLogFile(EngineLog, 'Вызываем InitializeDayNightSystem...');
      InitializeDayNightSystem;
      AddToLogFile(EngineLog, 'InitializeDayNightSystem завершена');
      AddToLogFile(EngineLog, 'HasDayNightFolders: ' + BoolToStr(HasDayNightFolders, True));
    end;
    
    // Применяем текстуры если система активна
    if HasDayNightFolders then
    begin
      AddToLogFile(EngineLog, 'Вызываем ApplyDayNightTextures...');
      ApplyDayNightTextures;
      AddToLogFile(EngineLog, 'ApplyDayNightTextures завершена');
    end
    else
    begin
      AddToLogFile(EngineLog, 'Система день/ночь отключена - пропускаем применение текстур');
    end;
    
    LastTimeCheck := currentTime;
    AddToLogFile(EngineLog, '=== ProcessDayNightSystem ЗАВЕРШЕНА ===');
  end;
end;



function WriteAndVerify(Address: Cardinal; Value: Integer; MaxAttempts: Integer = 10): Boolean;
var
  Addr: Pointer;
  OldProtect: DWORD;
  CurrentValue: Integer;
  Attempt: Integer;
begin
  Result := False;
  Addr := Pointer(Address);
  Attempt := 0;
  
  while (Attempt < MaxAttempts) do
  begin
    Inc(Attempt);
    
    try
      // Записываем значение
      if VirtualProtect(Addr, SizeOf(Integer), PAGE_EXECUTE_READWRITE, OldProtect) then
      begin
        PInteger(Addr)^ := Value;
        VirtualProtect(Addr, SizeOf(Integer), OldProtect, OldProtect);
        
        // Проверяем что записалось
        CurrentValue := PInteger(Addr)^;
        
        if CurrentValue = Value then
        begin
          Result := True;
          Break;
        end
        else
        begin
        end;
      end
      else
      begin
      end;
      
    except
      on E: Exception do
        //AddToLogFile(EngineLog, Format('Исключение на попытке %d: %s', [Attempt, E.Message]));
    end;

    // Небольшая задержка между попытками
    Sleep(1);
  end;

end;

// ===== ДОБАВИТЬ ФУНКЦИЮ ЗАГРУЗКИ КОНФИГА =====
// ===== ОБНОВЛЕННАЯ ФУНКЦИЯ LoadConfigFile (ТОЛЬКО ФРИКАМ) =====
procedure LoadConfigFile;
var
  f: TextFile;
  line: string;
  paramName, paramValue: string;
  colonPos: Integer;
  success: Boolean;
begin
  // Значения по умолчанию для фрикама
  Config_BaseSpeed := 0.5;
  Config_FastSpeed := 1.0;
  Config_TurnSpeed := 1.5;
  Config_MaxVisibleDistance := 1200;
  
  if FileExists('zdbooster.cfg') then
  begin
    try
      AssignFile(f, 'zdbooster.cfg');
      Reset(f);
      
      while not Eof(f) do
      begin
        ReadLn(f, line);
        line := Trim(line);
        
        // Пропускаем пустые строки и комментарии
        if (line = '') or (line[1] = '#') or (line[1] = ';') then Continue;
        
        colonPos := Pos(':', line);
        if colonPos > 0 then
        begin
          paramName := LowerCase(Trim(Copy(line, 1, colonPos - 1)));
          paramValue := Trim(Copy(line, colonPos + 1, Length(line)));
          
          try
            if paramName = 'basespeed' then
              Config_BaseSpeed := StrToFloat(StringReplace(paramValue, '.', ',', [rfReplaceAll]))
            else if paramName = 'fastspeed' then
              Config_FastSpeed := StrToFloat(StringReplace(paramValue, '.', ',', [rfReplaceAll]))
            else if paramName = 'turnspeed' then
              Config_TurnSpeed := StrToFloat(StringReplace(paramValue, '.', ',', [rfReplaceAll]))
            else if paramName = 'maxvisibledistance' then
              Config_MaxVisibleDistance := StrToInt(paramValue);
          except
            // Игнорируем ошибки преобразования
          end;
        end;
      end;
      
      CloseFile(f);
      
    except
      on E: Exception do
      begin
        AddToLogFile(EngineLog, 'Ошибка загрузки zdbooster.cfg: ' + E.Message);
        try
          CloseFile(f);
        except
        end;
      end;
    end;
  end
  else
  begin
    // Создаем обновленный файл конфигурации (только фрикам)
    try
      AssignFile(f, 'zdbooster.cfg');
      Rewrite(f);
      WriteLn(f, '# Конфигурация ZDBooster');
      WriteLn(f, '# Настройки отображения перенесены в booster.txt');
      WriteLn(f, '');
      WriteLn(f, '# ===== НАСТРОЙКИ ФРИКАМА =====');
      WriteLn(f, '# Базовая скорость движения (обычная)');
      WriteLn(f, 'basespeed: 0.5');
      WriteLn(f, '');
      WriteLn(f, '# Быстрая скорость движения (с зажатым Shift)');
      WriteLn(f, 'fastspeed: 1.0');
      WriteLn(f, '');
      WriteLn(f, '# Скорость поворота камеры (стрелками)');
      WriteLn(f, 'turnspeed: 1.5');
      WriteLn(f, '');
      WriteLn(f, '# Максимальная дистанция видимости (по умолчанию 800)');
      WriteLn(f, '# Влияет на дальность прорисовки объектов');
      WriteLn(f, 'maxvisibledistance: 1200');
      CloseFile(f);
      AddToLogFile(EngineLog, 'Создан обновленный zdbooster.cfg (только настройки фрикама)');
    except
      on E: Exception do
        AddToLogFile(EngineLog, 'Ошибка создания zdbooster.cfg: ' + E.Message);
    end;
  end;

  
  AddToLogFile(EngineLog, Format('Настройки фрикама: BaseSpeed=%.1f, FastSpeed=%.1f, TurnSpeed=%.1f, MaxDist=%d',
    [Config_BaseSpeed, Config_FastSpeed, Config_TurnSpeed, Config_MaxVisibleDistance]));
  
  ConfigLoaded := True;
end;


// Обработка фрикамы
procedure ProcessFreecam;
var
  CurrentTime: Cardinal;
  CurrentYaw, CurrentPitch: Single;
  CurrentX, CurrentY, CurrentZ: Single;
  YawRad, PitchRad: Single;
  ForwardX, ForwardY, ForwardZ: Single;
  RightX, RightY: Single;
  Speed: Single;
  NewYaw, NewPitch: Single;
begin
  if not FreecamInitialized then
    InitializeFreecam;
  
  CurrentTime := GetTickCount;
  
  // Обработка включения фрикамы (Alt + /)
  if IsKeyPressed(VK_MENU) and IsKeyPressed(VK_OEM_2) and // Alt + /
     (CurrentTime - LastFreecamToggle > FreecamKeyDelay) then
  begin
    if not FreecamEnabled then
    begin
      FreecamEnabled := True;
      if ApplyNopPatch then
      begin
        AddToLogFile(EngineLog, 'Freecam enabled, NOP patch applied');
        LastFreecamToggle := CurrentTime;

        end;
      end
      else
      begin
        FreecamEnabled := False;
        AddToLogFile(EngineLog, 'Failed to apply NOP patch');
      end;
    end;
  end
  
  // Обработка выключения фрикамы (/)
  else if IsKeyPressed(VK_OEM_2) and not IsKeyPressed(VK_MENU) and // / без Alt
          (CurrentTime - LastFreecamDisable > FreecamKeyDelay) then
  begin
    if FreecamEnabled then
    begin
      FreecamEnabled := False;
      
      // Восстанавливаем позицию
      WriteMemoryDouble(FREEMODE_SWITCH_ADDR, 0.0);
      WriteMemorySingle(ADDR_X, InitialX);
      WriteMemorySingle(ADDR_Y, InitialY);
      WriteMemorySingle(ADDR_Z, InitialZ);
      
      if RestoreOriginalBytes then
      begin
        AddToLogFile(EngineLog, 'Freecam disabled, original bytes restored');
        LastFreecamDisable := CurrentTime;
      end
      else
      begin
        AddToLogFile(EngineLog, 'Failed to restore original bytes');
      end;
    end;
  end;
  
  // Если фрикам не включен, выходим
  if not FreecamEnabled then Exit;
  
  // Читаем текущие значения камеры
  CurrentYaw := ReadMemorySingle(ADDR_LOOKYAW);
  CurrentPitch := ReadMemorySingle(ADDR_LOOKPITCH);
  CurrentX := ReadMemorySingle(ADDR_X);
  CurrentY := ReadMemorySingle(ADDR_Y);
  CurrentZ := ReadMemorySingle(ADDR_Z);
  
  // Ограничиваем pitch
  CurrentPitch := ClampPitch(CurrentPitch);
  
  // Нормализуем yaw
  while CurrentYaw >= 360.0 do
    CurrentYaw := CurrentYaw - 360.0;
  while CurrentYaw < 0.0 do
    CurrentYaw := CurrentYaw + 360.0;
  
  // Конвертируем в радианы
  YawRad := CurrentYaw * (Pi / 180.0);
  PitchRad := CurrentPitch * (Pi / 180.0);
  
  // Вычисляем направления
  ForwardX := cos(PitchRad) * sin(YawRad);
  ForwardY := cos(PitchRad) * cos(YawRad);
  ForwardZ := sin(PitchRad);
  
  RightX := sin(YawRad - Pi / 2);
  RightY := cos(YawRad - Pi / 2);
  
  // Определяем скорость - ИСПОЛЬЗУЕМ ПЕРЕМЕННЫЕ ИЗ КОНФИГА
  if IsKeyPressed(VK_SHIFT) then
    Speed := Config_FastSpeed
  else
    Speed := Config_BaseSpeed;
  
  // Обработка движения
  if IsKeyPressed(Ord('W')) then
  begin
    CurrentX := CurrentX + ForwardX * Speed;
    CurrentY := CurrentY + ForwardY * Speed;
    CurrentZ := CurrentZ + ForwardZ * Speed;
  end;
  
  if IsKeyPressed(Ord('S')) then
  begin
    CurrentX := CurrentX - ForwardX * Speed;
    CurrentY := CurrentY - ForwardY * Speed;
    CurrentZ := CurrentZ - ForwardZ * Speed;
  end;
  
  if IsKeyPressed(Ord('A')) then
  begin
    CurrentX := CurrentX + RightX * Speed;
    CurrentY := CurrentY + RightY * Speed;
  end;
  
  if IsKeyPressed(Ord('D')) then
  begin
    CurrentX := CurrentX - RightX * Speed;
    CurrentY := CurrentY - RightY * Speed;
  end;
  
  if IsKeyPressed(VK_SPACE) then
  begin
    CurrentZ := CurrentZ + Speed;
  end;
  
  // Обработка поворота камеры - ИСПОЛЬЗУЕМ ПЕРЕМЕННУЮ ИЗ КОНФИГА
  NewYaw := CurrentYaw;
  NewPitch := CurrentPitch;
  
  if IsKeyPressed(VK_UP) then
    NewPitch := NewPitch + Config_TurnSpeed;
  
  if IsKeyPressed(VK_DOWN) then
    NewPitch := NewPitch - Config_TurnSpeed;
  
  if IsKeyPressed(VK_LEFT) then
    NewYaw := NewYaw - Config_TurnSpeed;
  
  if IsKeyPressed(VK_RIGHT) then
    NewYaw := NewYaw + Config_TurnSpeed;
  
  // Ограничиваем pitch
  NewPitch := ClampPitch(NewPitch);



  // Применяем изменения
  WriteMemoryDouble(FREEMODE_SWITCH_ADDR, 2.3);
  WriteMemorySingle(ADDR_X, CurrentX);
  WriteMemorySingle(ADDR_Y, CurrentY);
  WriteMemorySingle(ADDR_Z, CurrentZ);
  WriteMemorySingle(ADDR_LOOKYAW, NewYaw);
  WriteMemorySingle(ADDR_LOOKPITCH, NewPitch);
end;


// ЕДИНСТВЕННАЯ функция обработки клавиатуры - убираем все дубли!
function ProcessKeyboard: Boolean;
var
  BaseAddr: Cardinal;
  KeyOffsets: array[0..11] of Cardinal;
  KeyChars: array[0..11] of string;
  i: Integer;
  CurrentVal, PreviousVal: Byte;
  WindowOpen: Byte;
  EnterJustPressed: Boolean;
  ExternalByte: Byte;
begin
  Result := False;
  EnterPressed := False;
  
  try
    
    // Инициализация массивов клавиш
    KeyOffsets[0] := $79;  KeyChars[0] := '0';
    KeyOffsets[1] := $85;  KeyChars[1] := '1';
    KeyOffsets[2] := $91;  KeyChars[2] := '2';
    KeyOffsets[3] := $9D;  KeyChars[3] := '3';
    KeyOffsets[4] := $A9;  KeyChars[4] := '4';
    KeyOffsets[5] := $B5;  KeyChars[5] := '5';
    KeyOffsets[6] := $C1;  KeyChars[6] := '6';
    KeyOffsets[7] := $CD;  KeyChars[7] := '7';
    KeyOffsets[8] := $D9;  KeyChars[8] := '8';
    KeyOffsets[9] := $E5;  KeyChars[9] := '9';
    KeyOffsets[10] := $61; KeyChars[10] := 'ENTER';
    KeyOffsets[11] := $F1; KeyChars[11] := 'CANCEL';

    BaseAddr := PCardinal(PointerAddress)^;

    ExternalByte := PByte(Pointer($00400000 + $34988C))^;
if (ExternalByte <> 30) and (ExternalByte <> 53) then
begin
  CommandBuffer := '';
end;

    // Инициализация состояний клавиш
    if not KeyStatesInitialized then
    begin
      for i := 0 to 11 do
        PreviousKeyStates[i] := PByte(BaseAddr + KeyOffsets[i])^;
      KeyStatesInitialized := True;
    end;
    
    EnterJustPressed := False;
    
    // Проверяем каждую клавишу на изменение состояния
    for i := 0 to 11 do
    begin
      CurrentVal := PByte(BaseAddr + KeyOffsets[i])^;
      PreviousVal := PreviousKeyStates[i];

      // Edge detection: клавиша была нажата (переход 0 -> 1)
      if (PreviousVal = 0) and (CurrentVal = 1) then
      begin
        if KeyChars[i] = 'ENTER' then
        begin
          EnterJustPressed := True;
          EnterPressed := True;
          //AddToLogFile(EngineLog, 'ENTER нажат, буфер: "' + CommandBuffer + '"');
        end
        else
        begin
          // Добавляем цифру к буферу
          CommandBuffer := CommandBuffer + KeyChars[i];
          //AddToLogFile(EngineLog, 'Добавлена цифра: ' + KeyChars[i] + ', буфер: "' + CommandBuffer + '"');
        end;
      end;
      
      // Обновляем предыдущее состояние
      PreviousKeyStates[i] := CurrentVal;
    end;
    
    // ИСПРАВЛЕННАЯ логика: обрабатываем завершенные команды
    if EnterJustPressed and (CommandBuffer <> '') then
    begin
      LastCommand := CommandBuffer;
      //AddToLogFile(EngineLog, 'Команда завершена: "' + LastCommand + '"');
      // НЕ очищаем CommandBuffer здесь - он будет очищен после обработки команды
      Result := True; // Сигнализируем о новой команде
    end;
    
  except
    on E: Exception do
    begin
      //AddToLogFile(EngineLog, 'Ошибка в ProcessKeyboard: ' + E.Message);
      KeyStatesInitialized := False;
    end;
  end;
end;




function SignalColor(code: Integer): Char;
begin
  case code of
    0: Result := 'Ч'; // Черный
    1: Result := 'К'; // Красный  
    2: Result := 'Ж'; // Желтый
    3: Result := 'З'; // Зеленый
    else Result := '?';
  end;
end;

function LoadDataFile(filename: string): TStringList;
var
  f: TextFile;
  line: string;
  piketNum: Integer;
begin
  Result := TStringList.Create;
  if FileExists(filename) then
  begin
    try
      AssignFile(f, filename);
      Reset(f);
      while not Eof(f) do
      begin
        ReadLn(f, line);
        line := Trim(line);
        if line <> '' then
        begin
          piketNum := StrToInt(Copy(line, 1, Pos(#9, line + #9) - 1));
          Result.Add(IntToStr(piketNum));
        end;
      end;
      CloseFile(f);
    except
      // Игнорируем ошибки
    end;
  end;
end;

function CompareStrings(List: TStringList; Index1, Index2: Integer): Integer;
begin
  Result := StrToInt(List[Index1]) - StrToInt(List[Index2]);
end;


// Добавляем недостающую функцию ArtificialSignalColor
function ArtificialSignalColor(code: Integer): string;
begin
  case code of
    0: Result := 'В';  // Выключен  
    1: Result := 'Б';  // Белый
    2: Result := 'К';  // Красный
    3: Result := 'КЖ'; // Красно-желтый
    4: Result := 'Ж';  // Желтый
    5: Result := 'З';  // Зеленый
    else Result := '?';
  end;
end;

function GetSignalSequence: string;
var
  i, j, piketNum, signalState, currentPiket, closestIndex, minDistance: Integer;
  offset, baseAddr, currentPiketAddr, trafficLightAddr: Cardinal;
  oneDirection: Boolean;
  trafficLightState: Byte;
  piketData: array of record
    offset: Cardinal;
    piketNum: Integer;
    signalState: Integer;
  end;
  filteredPikets, uniquePikets: TStringList;
  displayStart, displayEnd: Integer;
  tempIndex: Integer;
  existingOffset, newOffset: Cardinal;
begin
  Result := '';
  
  baseAddr := $900805C;
  currentPiketAddr := $749A0C;
  trafficLightAddr := $400000 + $8C07ECC;
  oneDirection := PByte(Pointer($749818))^ = 1;
  currentPiket := PInteger(Pointer(currentPiketAddr))^;
  trafficLightState := PByte(Pointer(trafficLightAddr))^;
  
  // Собираем данные о пикетах
  SetLength(piketData, s1.Count + s2.Count);
  for i := 0 to High(piketData) do
  begin
    offset := baseAddr + $858 * Cardinal(i);
    piketData[i].offset := offset;
    piketData[i].piketNum := PInteger(Pointer(offset))^;
    piketData[i].signalState := PInteger(Pointer(offset + $70))^;
  end;
  
  // Фильтруем по направлению
  filteredPikets := TStringList.Create;
  uniquePikets := TStringList.Create;
  try
    // Сначала фильтруем по направлению
    for i := 0 to High(piketData) do
    begin
      if oneDirection then
      begin
        if s1.IndexOf(IntToStr(piketData[i].piketNum)) >= 0 then
          filteredPikets.AddObject(IntToStr(piketData[i].piketNum), TObject(i));
      end
      else
      begin
        if s2.IndexOf(IntToStr(piketData[i].piketNum)) >= 0 then
          filteredPikets.AddObject(IntToStr(piketData[i].piketNum), TObject(i));
      end;
    end;
    
    // ВАЖНО: Убираем дубликаты, выбирая нужный адрес в зависимости от направления
    for i := 0 to filteredPikets.Count - 1 do
    begin
      piketNum := StrToInt(filteredPikets[i]);
      tempIndex := Integer(filteredPikets.Objects[i]);
      newOffset := piketData[tempIndex].offset;
      
      j := uniquePikets.IndexOf(IntToStr(piketNum));
      if j = -1 then
      begin
        // Пикета еще нет - добавляем
        uniquePikets.AddObject(IntToStr(piketNum), TObject(tempIndex));
      end
      else
      begin
        // Пикет уже есть - выбираем нужный адрес
        existingOffset := piketData[Integer(uniquePikets.Objects[j])].offset;
        
        if oneDirection then
        begin
          // Для прямого направления выбираем меньший адрес
          if newOffset < existingOffset then
            uniquePikets.Objects[j] := TObject(tempIndex);
        end
        else
        begin
          // Для обратного направления выбираем больший адрес
          if newOffset > existingOffset then
            uniquePikets.Objects[j] := TObject(tempIndex);
        end;
      end;
    end;
    
    // Сортируем по номеру пикета
    uniquePikets.CustomSort(CompareStrings);
    
    // Находим ближайший следующий пикет
    closestIndex := -1;
    minDistance := MaxInt;
    
    for i := 0 to uniquePikets.Count - 1 do
    begin
      piketNum := StrToInt(uniquePikets[i]);
      if oneDirection then
      begin
        if (piketNum > currentPiket) and (piketNum - currentPiket < minDistance) then
        begin
          closestIndex := i;
          minDistance := piketNum - currentPiket;
        end;
      end
      else
      begin
        if (piketNum < currentPiket) and (currentPiket - piketNum < minDistance) then
        begin
          closestIndex := i;
          minDistance := currentPiket - piketNum;
        end;
      end;
    end;
    
    if closestIndex >= 0 then
    begin
      // Определяем диапазон для анализа (как в Python)
      if oneDirection then
      begin
        displayStart := Max(closestIndex - 1, 0);
        displayEnd := Min(closestIndex + 4, uniquePikets.Count - 1);
      end
      else
      begin
        displayStart := Max(closestIndex - 5, 0);
        displayEnd := closestIndex;
      end;
      
      // Формируем последовательность сигналов
      if oneDirection then
      begin
        // Прямое направление - как есть
        for i := displayStart to displayEnd do
        begin
          j := Integer(uniquePikets.Objects[i]);
          Result := Result + SignalColor(piketData[j].signalState);
          // Останавливаемся на черном сигнале
          if piketData[j].signalState = 0 then Break;
        end;
      end
      else
      begin
        // Обратное направление - в обратном порядке (как [::-1] в Python)
        for i := displayEnd downto displayStart do
        begin
          j := Integer(uniquePikets.Objects[i]);
          Result := Result + SignalColor(piketData[j].signalState);
          // Останавливаемся на черном сигнале
          if piketData[j].signalState = 0 then Break;
        end;
      end;
    end;
    
    // Добавляем префикс искусственного светофора для обратного направления (как в Python)
    if not oneDirection then
    begin
      Result := ArtificialSignalColor(trafficLightState) + Result;
    end;
    
  finally
    filteredPikets.Free;
    uniquePikets.Free;
  end;
end;

function GetRouteName: string;
var
  addr: Cardinal;
  buffer: array[0..255] of Char;
  bytesRead: Cardinal;
  fullString: string;
  slashPos: Integer;
  processHandle: THandle;
  i: Integer;
begin
  Result := '';
  
  try
    // Получаем хендл текущего процесса
    processHandle := GetCurrentProcess();
    
    // Адрес строки маршрута
    addr := $400000 + $8DD46D7;
    
    // Читаем строку из памяти
    FillChar(buffer, SizeOf(buffer), 0);
    if ReadProcessMemory(processHandle, Pointer(addr), @buffer, 256, bytesRead) then
    begin
      // Находим конец строки (первый нулевой символ)
      i := 0;
      while (i < 256) and (buffer[i] <> #0) do
        Inc(i);
      
      // Преобразуем в строку
      SetString(fullString, buffer, i);
      
      // Извлекаем название до первого обратного слеша
      slashPos := Pos('\', fullString);
      if slashPos > 0 then
        Result := Copy(fullString, 1, slashPos - 1)
      else
        Result := fullString;
        
      //AddToLogFile(EngineLog, 'Название маршрута: "' + Result + '"');
    end
    else
    begin
      //AddToLogFile(EngineLog, 'Не удалось прочитать название маршрута из памяти');
    end;

  except
    on E: Exception do
    begin
      //AddToLogFile(EngineLog, 'Ошибка при получении названия маршрута: ' + E.Message);
      Result := '';
    end;
  end;
end;

procedure InitializeTrafficLightSystem;
var
  routeName: string;
  filePath1, filePath2: string;
begin
  if TrafficSystemInitialized then Exit;
  
  // Получаем название маршрута
  routeName := GetRouteName;
  
  // Формируем пути к файлам
  if routeName <> '' then
  begin
    filePath1 := 'routes\' + routeName + '\svetofor1.dat';
    filePath2 := 'routes\' + routeName + '\svetofor2.dat';
  end
  else
  begin
    // Fallback на стандартные файлы
    filePath1 := 'svetofor1.dat';
    filePath2 := 'svetofor2.dat';
  end;
  
  // Инициализируем списки пикетов
  if not Assigned(s1) then s1 := LoadDataFile(filePath1);
  if not Assigned(s2) then s2 := LoadDataFile(filePath2);
  
  //AddToLogFile(EngineLog, 'Загружен файл svetofor1: ' + filePath1);
  //AddToLogFile(EngineLog, 'Загружен файл svetofor2: ' + filePath2);
  
  TrafficSystemInitialized := True;
end;

procedure Draw3DDisk(Radius: Single);
var
  quad: PGLUquadric;
begin
  quad := gluNewQuadric;
  gluQuadricDrawStyle(quad, GLU_FILL);
  gluDisk(quad, 0.0, Radius, 64, 1); // внутренний радиус = 0 → круг
  gluDeleteQuadric(quad);
end;

procedure Draw3DSemiCircle(Radius: Single; StartAngle, EndAngle: Single);
var
  i: Integer;
  angle: Single;
  x, y: Single;
  segments: Integer;
begin
  segments := 32; // Количество сегментов для плавности
  
  glBegin(GL_TRIANGLE_FAN);
    glVertex3f(0, 0, 0); // Центр полукруга
    
    for i := 0 to segments do
    begin
      angle := StartAngle + (EndAngle - StartAngle) * i / segments;
      angle := angle * (Pi / 180.0); // Конвертируем в радианы
      x := Radius * cos(angle);
      y := Radius * sin(angle);
      glVertex3f(x, y, 0);
    end;
  glEnd;
end;

procedure Draw3DArcProgress(Radius: Single; StartAngleDeg, EndAngleDeg: Single; CurrentValue, MaxValue: Single; Segments: Integer);
var
  i: Integer;
  angle, angleStep, endAngleCurrent: Single;
  x, y: Single;
begin
  // Рассчитываем угол текущей скорости (прогресса)
  if CurrentValue > MaxValue then CurrentValue := MaxValue;
  if CurrentValue < 0 then CurrentValue := 0;
  
  angleStep := (EndAngleDeg - StartAngleDeg) / Segments;
  endAngleCurrent := StartAngleDeg + (CurrentValue / MaxValue) * (EndAngleDeg - StartAngleDeg);

  glBegin(GL_TRIANGLE_FAN);
    glVertex3f(0, 0, 0); // центр дуги

    // Рисуем дугу от StartAngleDeg до endAngleCurrent (текущий прогресс)
    for i := 0 to Segments do
    begin
      angle := StartAngleDeg + i * angleStep;
      if angle > endAngleCurrent then
        break;  // не выходить за текущий угол прогресса
      
      angle := angle * (Pi / 180.0); // в радианы
      x := Radius * cos(angle);
      y := Radius * sin(angle);
      glVertex3f(x, y, 0);
    end;

  glEnd;
end;


var
  PosX, PosY, PosZ: Double;
  Color: Longint;
  Alpha: Integer;
  UseLighting: Boolean;
  ExtraParam: Double;
  PosLine, ColorLine: string;
  F: TextFile;


procedure HookKLUBED4M(
 x: Single;
        y: Single;
        z: Single;
        AngX: Single;
        AngZ: Single
); stdcall; export;
begin
  
end;

procedure HookKLUB(
  x: Single;
  y: Single;
  z: Single;
  AngZ: Single
); stdcall; export;


type
  TObjectParams = record
    X, Y, Z: Single;
    RotX, RotY, RotZ: Single;
    Scale: Single;
    Text: string;
    Color: Integer;
    FuncType: Integer;
  end;

const
  debug = True;
  BaseAddress: Cardinal = $00400000;

var
  StaticData: array[0..35] of TObjectParams;
  obj: TObjectParams;
  parts: TStringList;
  f: TextFile;
  line: string;
  arrowAngle: Single;
  arrowX, arrowY, arrowZ, arrowScale: Single;
  arrowRotation: Single;
  currentSpeed: Single;
  speedAngle: Single;
  i: Integer;
  initialized: Boolean;
  NewCommandReceived: Boolean;
  
  // Переменные для светофоров
  signalSequence: string;
  signalChar: Char;
  signalIndex: Integer;
  mainTrafficLight: Byte;
  visibleSignalCount: Integer;

  File3D: TextFile;
  PosX, PosY, PosZ: Single;
  RotX3D, RotY3D: Single;
  Scale3DVal: Single;
    diskX, diskY, diskZ: Single;
    diskRotX, diskRotY: Single;
    diskScale: Single;
    diskRadius: Integer;

  textureAddr, modelAddr: Pointer;
  textureID: Cardinal;
  modelID: Integer;

  baseStructAddr: Cardinal;
  yellowBlockModelAddr, greenBlockModelAddr: Pointer;
  yellowBlockModelID, greenBlockModelID: Word;

      alsValue: Byte;
    diskColor: Integer;

function GetSpeedDigit(position: Integer): string;
var
  speedStr: string;
  speedValue: Integer;
begin
  Result := '';
  try
    speedValue := GetSpeedValue; // Используем новую функцию из KlubData
    speedStr := IntToStr(speedValue);
    
    // Дополняем нулями слева до 3 знаков
    while Length(speedStr) < 3 do
      speedStr := '0' + speedStr;
    
    // Возвращаем цифру в нужной позиции (1, 2 или 3)
    if (position >= 1) and (position <= Length(speedStr)) then
      Result := speedStr[position];
  except
    Result := '0';
  end;
end;

// Функция для получения цифры допустимой скорости по позиции
function GetLimitSpeedDigit(position: Integer): string;
var
  limitStr: string;
  limitValue: Integer;
begin
  Result := '';
  try
    limitValue := GetLimitSpeedValue; // Используем функцию из KlubData
    limitStr := IntToStr(limitValue);
    
    // Дополняем нулями слева до 3 знаков
    while Length(limitStr) < 3 do
      limitStr := '0' + limitStr;
    
    // Возвращаем цифру в нужной позиции (1, 2 или 3)
    if (position >= 1) and (position <= Length(limitStr)) then
      Result := limitStr[position];
  except
    Result := '0';
  end;
end;

// Функция для получения цифры расстояния по позиции
function GetDistanceDigit(position: Integer): string;
var
  distanceStr: string;
  distanceValue: Integer;
begin
  Result := '';
  try
    distanceValue := GetDistanceValue; // Используем новую функцию из KlubData
    distanceStr := IntToStr(distanceValue);
    
    // Дополняем нулями слева до 4 знаков
    while Length(distanceStr) < 4 do
      distanceStr := '0' + distanceStr;
    
    // Возвращаем цифру в нужной позиции (1, 2, 3 или 4)
    if (position >= 1) and (position <= Length(distanceStr)) then
      Result := distanceStr[position];
  except
    Result := '0';
  end;
end;

procedure InitializeStaticData;
begin
  if initialized then Exit;
  
  // Элементы 0-13 - основные данные (обновленные координаты)
  with StaticData[0] do begin X:=1.0268; Y:=7.3762; Z:=3.558; RotX:=-105; RotY:=35; RotZ:=-8.5; Scale:=0.013; Text:='222'; Color:=$FFFFFF; FuncType:=11; end;
  with StaticData[1] do begin X:=1.029; Y:=7.37896; Z:=3.538; RotX:=-105; RotY:=35; RotZ:=-8.5; Scale:=0.01; Text:='2222'; Color:=$FFFFFF; FuncType:=2; end;
  with StaticData[2] do begin X:=1.0305; Y:=7.3807; Z:=3.525; RotX:=-105; RotY:=35; RotZ:=-8.5; Scale:=0.0055; Text:='25.05.25'; Color:=$FFFFFF; FuncType:=3; end;
  with StaticData[3] do begin X:=1.031; Y:=7.38165; Z:=3.519; RotX:=-105; RotY:=35; RotZ:=-8.5; Scale:=0.0055; Text:='22:47:00'; Color:=$FFFFFF; FuncType:=4; end;
  with StaticData[4] do begin X:=0.854; Y:=7.50365; Z:=3.528; RotX:=-105; RotY:=35; RotZ:=-8.0; Scale:=0.0065; Text:='8.01'; Color:=$FFFFFF; FuncType:=5; end;
  with StaticData[5] do begin X:=0.855; Y:=7.50489; Z:=3.519; RotX:=-105; RotY:=35; RotZ:=-8.0; Scale:=0.0065; Text:='8.02'; Color:=$FFFFFF; FuncType:=0; end;
  with StaticData[6] do begin X:=0.853; Y:=7.5022; Z:=3.538; RotX:=-105; RotY:=35; RotZ:=-8.0; Scale:=0.0065; Text:='8.03'; Color:=$FFFFFF; FuncType:=6; end;
  with StaticData[7] do begin X:=0.852; Y:=7.5007; Z:=3.548; RotX:=-105; RotY:=35; RotZ:=-8.0; Scale:=0.0065; Text:='8.04'; Color:=$FFFFFF; FuncType:=7; end;
  with StaticData[8] do begin X:=0.87; Y:=7.4842; Z:=3.566; RotX:=-105; RotY:=35; RotZ:=-8.0; Scale:=0.0065; Text:='1.05'; Color:=$008000; FuncType:=8; end;
  with StaticData[9] do begin X:=0.893; Y:=7.4694; Z:=3.560; RotX:=-105; RotY:=35; RotZ:=-8.0; Scale:=0.015; Text:='222'; Color:=$FFFFFF; FuncType:=1; end;
  with StaticData[10] do begin X:=0.992; Y:=7.3987; Z:=3.566; RotX:=-105; RotY:=34; RotZ:=-8.0; Scale:=0.007; Text:='12312311'; Color:=$FFFFFF; FuncType:=9; end;
  with StaticData[11] do begin X:=1.019; Y:=7.3585; Z:=3.665; RotX:=-105; RotY:=35; RotZ:=-8.0; Scale:=0.008; Text:='Путь'; Color:=$FFFFFF; FuncType:=0; end;
  with StaticData[12] do begin X:=1.022; Y:=7.3584; Z:=3.656; RotX:=-105; RotY:=35; RotZ:=-8.0; Scale:=0.008; Text:='n'; Color:=$FFFFFF; FuncType:=10; end;
  with StaticData[13] do begin X:=1.01; Y:=7.3842; Z:=3.575; RotX:=-105; RotY:=34; RotZ:=-8.0; Scale:=0.008; Text:='222'; Color:=$FFFFFF; FuncType:=11; end;
  
  // Элементы 14-16 - Скорость (желтый, 3 позиции)
  with StaticData[14] do begin X:=0.9235; Y:=7.455; Z:=3.386; RotX:=-70; RotY:=20; RotZ:=7.0; Scale:=0.019; Text:='1'; Color:=$00FFFF; FuncType:=20; end; // 1-я позиция скорости
  with StaticData[15] do begin X:=0.935; Y:=7.451; Z:=3.386; RotX:=-70; RotY:=20; RotZ:=7.0; Scale:=0.019; Text:='2'; Color:=$00FFFF; FuncType:=21; end; // 2-я позиция скорости
  with StaticData[16] do begin X:=0.9465; Y:=7.447; Z:=3.386; RotX:=-70; RotY:=20; RotZ:=7.0; Scale:=0.019; Text:='3'; Color:=$00FFFF; FuncType:=22; end; // 3-я позиция скорости
  
  // Элементы 17-19 - Допустимая скорость (красный, 3 позиции)
  with StaticData[17] do begin X:=0.922; Y:=7.450; Z:=3.364; RotX:=-70; RotY:=20; RotZ:=7.0; Scale:=0.019; Text:='4'; Color:=$0000FF; FuncType:=23; end; // 1-я позиция допустимой
  with StaticData[18] do begin X:=0.9335; Y:=7.446; Z:=3.364; RotX:=-70; RotY:=20; RotZ:=7.0; Scale:=0.019; Text:='5'; Color:=$0000FF; FuncType:=24; end; // 2-я позиция допустимой
  with StaticData[19] do begin X:=0.945; Y:=7.442; Z:=3.364; RotX:=-70; RotY:=20; RotZ:=7.0; Scale:=0.019; Text:='6'; Color:=$0000FF; FuncType:=25; end; // 3-я позиция допустимой
  
  // Элементы 20-23 - Расстояние до цели (красный, 4 позиции)
  with StaticData[20] do begin X:=0.852; Y:=7.471; Z:=3.366; RotX:=-70; RotY:=20; RotZ:=7.0; Scale:=0.019; Text:='1'; Color:=$0000FF; FuncType:=26; end; // 1-я позиция расстояния
  with StaticData[21] do begin X:=0.863; Y:=7.4674; Z:=3.366; RotX:=-70; RotY:=20; RotZ:=7.0; Scale:=0.019; Text:='2'; Color:=$0000FF; FuncType:=27; end; // 2-я позиция расстояния
  with StaticData[22] do begin X:=0.874; Y:=7.4638; Z:=3.366; RotX:=-70; RotY:=20; RotZ:=7.0; Scale:=0.019; Text:='3'; Color:=$0000FF; FuncType:=28; end; // 3-я позиция расстояния
  with StaticData[23] do begin X:=0.885; Y:=7.4602; Z:=3.366; RotX:=-70; RotY:=20; RotZ:=7.0; Scale:=0.019; Text:='4'; Color:=$0000FF; FuncType:=29; end; // 4-я позиция расстояния
  
  // Элементы 24-27 - Светофорная система АЛС
  with StaticData[24] do begin X:=1.111; Y:=7.239; Z:=3.729; RotX:=-90; RotY:=40; RotZ:=-90; Scale:=0.015; Text:='|'; Color:=$00FF00; FuncType:=30; end;
  with StaticData[25] do begin X:=1.113; Y:=7.237; Z:=3.733; RotX:=-90; RotY:=40; RotZ:=-90; Scale:=0.015; Text:='l'; Color:=$00FF00; FuncType:=31; end;
  with StaticData[26] do begin X:=1.107; Y:=7.243; Z:=3.7283; RotX:=-90; RotY:=30; RotZ:=-55; Scale:=0.018; Text:='-'; Color:=$00FF00; FuncType:=32; end;
  with StaticData[27] do begin X:=1.111; Y:=7.239; Z:=3.739; RotX:=-90; RotY:=40; RotZ:=-90; Scale:=0.015; Text:='||'; Color:=$00FF00; FuncType:=33; end;
  
  // Элементы 28-29 - "Следует графиком"
  with StaticData[28] do begin X:=0.8665; Y:=7.488; Z:=3.56; RotX:=-105; RotY:=35; RotZ:=-8.0; Scale:=0.005; Text:='следует'; Color:=$008000; FuncType:=0; end;
  with StaticData[29] do begin X:=0.8675; Y:=7.4881; Z:=3.556; RotX:=-105; RotY:=35; RotZ:=-8.0; Scale:=0.005; Text:='графику'; Color:=$008000; FuncType:=0; end;
  
  // Элементы 30-33 - Задание и расписание
  with StaticData[30] do begin X:=0.865; Y:=7.4918; Z:=3.547; RotX:=-105; RotY:=35; RotZ:=-8.0; Scale:=0.0065; Text:=''; Color:=$FFFFFF; FuncType:=12; end; // Задание
  with StaticData[31] do begin X:=0.866; Y:=7.493; Z:=3.538; RotX:=-105; RotY:=35; RotZ:=-8.0; Scale:=0.0065; Text:='РАСПИСАНИЕ'; Color:=$FFFFFF; FuncType:=13; end;
  with StaticData[32] do begin X:=0.87; Y:=7.4923; Z:=3.528; RotX:=-105; RotY:=35; RotZ:=-8.0; Scale:=0.0065; Text:=''; Color:=$FFFFFF; FuncType:=14; end; // Текущая станция
  with StaticData[33] do begin X:=0.871; Y:=7.4936; Z:=3.519; RotX:=-105; RotY:=35; RotZ:=-8.0; Scale:=0.0065; Text:=''; Color:=$FFFFFF; FuncType:=15; end; // Следующая станция

  with StaticData[34] do begin X:=0.142; Y:=7.48; Z:=3.162; RotX:=-57.3; RotY:=0.0; RotZ:=0.0; Scale:=0.016; Text:='1'; Color:=$0000FF; FuncType:=34; end;  // 1-я позиция float
  with StaticData[35] do begin X:=0.1533; Y:=7.48; Z:=3.162; RotX:=-57.3; RotY:=0.0; RotZ:=0.0; Scale:=0.016; Text:='3'; Color:=$0000FF; FuncType:=35; end; // 2-я позиция float

  initialized := True;
end;

function GetFloatDigit(position: Integer): string;
var
  currentFloatValue: Single;
  floatStr: string;
begin
  Result := '0'; // По умолчанию
  
  try
    // Читаем float из памяти
    currentFloatValue := PSingle(Pointer(FloatValueAddr))^;
    
    // Конвертируем в целое число
    FloatAsInt := Round(currentFloatValue);
    if FloatAsInt < 0 then FloatAsInt := 0; // Защита от отрицательных
    
    // Конвертируем в строку
    floatStr := IntToStr(FloatAsInt);
    
    // Дополняем нулями слева до 2 знаков для позиций 1-2
    while Length(floatStr) < 2 do
      floatStr := '0' + floatStr;
    
    // Возвращаем цифру в нужной позиции
    if (position >= 1) and (position <= Length(floatStr)) then
      Result := floatStr[position]
    else
      Result := '0';
      
  except
    on E: Exception do
    begin
      //AddToLogFile(EngineLog, 'Ошибка чтения float: ' + E.Message);
      Result := '0';
    end;
  end;
end;

// Функция для проверки, нужно ли показывать цифру float
function ShouldShowFloatDigit(position: Integer): Boolean;
var
  currentFloatValue: Single;
  floatAsInt: Integer;
  floatStr: string;
begin
  Result := False;
  
  try
    currentFloatValue := PSingle(Pointer(FloatValueAddr))^;
    floatAsInt := Round(currentFloatValue);
    if floatAsInt < 0 then floatAsInt := 0;
    
    floatStr := IntToStr(floatAsInt);
    
    case position of
      1: Result := (Length(floatStr) >= 2) or (floatAsInt >= 10); // 1-я позиция - показывать если >= 10
      2: Result := True; // 2-я позиция - всегда показывать
    end;
    
  except
    Result := False;
  end;
end;

// Добавьте эту функцию в начало implementation секции:
function ExtractField(const S: string; FieldNum: Integer; Delimiter: Char): string;
var
  i, FieldCount, StartPos: Integer;
begin
  Result := '';
  FieldCount := 1;
  StartPos := 1;
  
  for i := 1 to Length(S) do
  begin
    if S[i] = Delimiter then
    begin
      if FieldCount = FieldNum then
      begin
        Result := Copy(S, StartPos, i - StartPos);
        Exit;
      end;
      Inc(FieldCount);
      StartPos := i + 1;
    end;
  end;
  
  if FieldCount = FieldNum then
    Result := Copy(S, StartPos, Length(S) - StartPos + 1);
end;

function TrimString(const S: string): string;
var
  i, L: Integer;
begin
  L := Length(S);
  i := 1;
  while (i <= L) and (S[i] <= ' ') do Inc(i);
  if i > L then Result := '' else
  begin
    while (L > 0) and (S[L] <= ' ') do Dec(L);
    Result := Copy(S, i, L - i + 1);
  end;
end;

// Загрузка станций из памяти игры (исправленная версия)
procedure LoadStations;
var
  baseStationAddress: Cardinal;
  stationsCount: Byte;
  i: Integer;
  nameAddress, piketAddress: Cardinal;
  stationName: string;
  stationPiket: Integer;
  buffer: array[0..63] of Char; // Увеличили буфер до 64 символов
  nameLength: Byte;
begin
  if StationsLoaded then Exit;
  
  if not Assigned(StationsList) then
    StationsList := TStringList.Create;
  
  try
    // Получаем базовый адрес станций (как в Python)
    baseStationAddress := PCardinal(Pointer($00400000 + $403AEC))^ - $04;
    stationsCount := PByte(Pointer(baseStationAddress))^;
    
    //AddToLogFile(EngineLog, 'Найдено станций: ' + IntToStr(stationsCount));
    
    // Читаем все станции
    for i := 0 to stationsCount - 1 do
    begin
      try
        // Читаем имя станции
        nameAddress := PCardinal(Pointer($00400000 + $403AEC))^ + $70 + i * $48;
        
        // Сначала читаем длину строки
        nameLength := PByte(Pointer(nameAddress))^;
        if nameLength > 63 then nameLength := 63; // Ограничиваем для безопасности
        
        // Очищаем буфер
        FillChar(buffer, SizeOf(buffer), 0);
        
        // Читаем строку полностью по её длине
        if nameLength > 0 then
          Move(Pointer(nameAddress + 1)^, buffer, nameLength);
        
        stationName := Trim(UpperCase(string(buffer))); // ВЕРХНИЙ РЕГИСТР
        
        // Читаем пикет станции
        piketAddress := PCardinal(Pointer($00400000 + $403AEC))^ + $48 + i * $48;
        stationPiket := PInteger(Pointer(piketAddress))^;
        
        // Сохраняем как "название|пикет"
        if stationName <> '' then
        begin
          StationsList.Add(stationName + '|' + IntToStr(stationPiket));
          //AddToLogFile(EngineLog, 'Станция: ' + stationName + ' пикет: ' + IntToStr(stationPiket));
        end;
        
      except
        // Пропускаем ошибки чтения отдельных станций
        Continue;
      end;
    end;
    
    StationsLoaded := True;
    //AddToLogFile(EngineLog, 'Станции загружены из памяти игры');
    
  except
    on E: Exception do
    begin
      //AddToLogFile(EngineLog, 'Ошибка загрузки станций из памяти: ' + E.Message);
      // Fallback на пустой список
      StationsList.Clear;
    end;
  end;
end;

// Поиск станции по пикету (как в Python с погрешностью ±50)
function FindStationByPiket(currentPiket: Integer): string;
var
  i, stationPiket, minDistance, distance: Integer;
  parts: TStringList;
  bestMatch: string;
begin
  Result := '';
  LoadStations;
  
  if StationsList.Count = 0 then Exit;
  
  minDistance := MaxInt;
  bestMatch := '';
  parts := TStringList.Create;
  try
    for i := 0 to StationsList.Count - 1 do
    begin
      parts.Delimiter := '|';
      parts.DelimitedText := StationsList[i];
      if parts.Count >= 2 then
      begin
        try
          stationPiket := StrToInt(parts[1]);
          distance := Abs(currentPiket - stationPiket);
          
          // Ищем станцию с погрешностью ±50 км
          if (distance <= 50) and (distance < minDistance) then
          begin
            minDistance := distance;
            bestMatch := UpperCase(parts[0]); // ВЕРХНИЙ РЕГИСТР - ИСПРАВЛЕНО!
          end;
        except
          Continue;
        end;
      end;
    end;
  finally
    parts.Free;
  end;
  
  Result := bestMatch;
end;

// Улучшенная функция поиска текущей и следующей станции
procedure FindCurrentAndNextStation;
type
  TStationRecord = record
    name: string;
    piket: Integer;
    distance: Integer;
  end;
var
  currentPiket: Integer;
  i, stationPiket: Integer;
  parts: TStringList;
  currentTime: Cardinal;
  
  // Массивы станций по направлениям  
  stations: array[0..49] of TStationRecord;
  stationCount: Integer;
  
  currentStationIndex: Integer;
  nextStationIndex: Integer;
  minDistance: Integer;
  j: Integer;
  tempStation: TStationRecord;
  
  // Переменные для определения направления
  oneDirection: Boolean;
  directionStr: string;

begin
  // Проверяем кэш
  currentTime := timeGetTime;
  if (LastStationUpdate > 0) and (currentTime - LastStationUpdate < StationUpdateInterval) then
    Exit;
  
  LoadStations;
  
  // Читаем текущий пикет и направление из памяти
  currentPiket := PWord(Pointer($00400000 + $8C08054))^;
  
  // Определяем направление движения (как в Python коде)
  oneDirection := PByte(Pointer($749818))^ = 1;
  
  if oneDirection then
    directionStr := 'прямое'
  else
    directionStr := 'обратное';
    
  //AddToLogFile(EngineLog, Format('Текущий пикет: %d, Направление: %s',
  //  [currentPiket, directionStr]));
  
  // Собираем все станции
  stationCount := 0;
  parts := TStringList.Create;
  try
    for i := 0 to StationsList.Count - 1 do
    begin
      parts.Delimiter := '|';
      parts.DelimitedText := StationsList[i];
      if parts.Count >= 2 then
      begin
        try
          stationPiket := StrToInt(parts[1]);
          
          if stationCount < 50 then
          begin
            stations[stationCount].name := UpperCase(Trim(parts[0]));
            stations[stationCount].piket := stationPiket;
            stations[stationCount].distance := Abs(currentPiket - stationPiket);
            Inc(stationCount);
          end;
        except
          Continue;
        end;
      end;
    end;
  finally
    parts.Free;
  end;
  
  // Сортируем станции по пикетам (по возрастанию)
  for i := 0 to stationCount - 2 do
  begin
    for j := i + 1 to stationCount - 1 do
    begin
      if stations[j].piket < stations[i].piket then
      begin
        tempStation := stations[i];
        stations[i] := stations[j];
        stations[j] := tempStation;
      end;
    end;
  end;
  
  // Ищем текущую станцию (ближайшую с погрешностью ±50)
  CurrentStationName := 'НЕТ ДАННЫХ';
  currentStationIndex := -1;
  minDistance := MaxInt;
  
  for i := 0 to stationCount - 1 do
  begin
    if stations[i].distance <= 50 then
    begin
      if stations[i].distance < minDistance then
      begin
        minDistance := stations[i].distance;
        CurrentStationName := UpperCase(stations[i].name);
        currentStationIndex := i;
      end;
    end;
  end;
  
  // Если НЕТ ДАННЫХ - используем следующую станцию как текущую
  if CurrentStationName = 'НЕТ ДАННЫХ' then
  begin
    // Ищем ближайшую станцию по направлению движения
    minDistance := MaxInt;
    currentStationIndex := -1;
    
    if oneDirection then
    begin
      // Прямое направление - ищем ближайшую станцию впереди
      for i := 0 to stationCount - 1 do
      begin
        if stations[i].piket > currentPiket then
        begin
          if (stations[i].piket - currentPiket) < minDistance then
          begin
            minDistance := stations[i].piket - currentPiket;
            CurrentStationName := UpperCase(stations[i].name);
            currentStationIndex := i;
          end;
        end;
      end;
    end
    else
    begin
      // Обратное направление - ищем ближайшую станцию позади
      for i := stationCount - 1 downto 0 do
      begin
        if stations[i].piket < currentPiket then
        begin
          if (currentPiket - stations[i].piket) < minDistance then
          begin
            minDistance := currentPiket - stations[i].piket;
            CurrentStationName := UpperCase(stations[i].name);
            currentStationIndex := i;
          end;
        end;
      end;
    end;
  end;
  
  // Ищем следующую станцию по маршруту (ВСЕГДА ищем от найденной текущей)
  NextStationName := 'КОНЕЧНАЯ';
  nextStationIndex := -1;
  
  if (currentStationIndex >= 0) and (currentStationIndex < stationCount) then
  begin
    if oneDirection then
    begin
      // Прямое направление - ищем станцию с большим пикетом
      for i := currentStationIndex + 1 to stationCount - 1 do
      begin
        NextStationName := UpperCase(stations[i].name);
        nextStationIndex := i;
        Break;
      end;
    end
    else
    begin
      // Обратное направление - ищем станцию с меньшим пикетом
      for i := currentStationIndex - 1 downto 0 do
      begin
        NextStationName := UpperCase(stations[i].name);
        nextStationIndex := i;
        Break;
      end;
    end;
  end;
  
  // Обновляем время последнего обновления
  LastStationUpdate := currentTime;
  
 // AddToLogFile(EngineLog, Format('Найдено станций: %d, Текущая: "%s" (индекс: %d), Следующая: "%s" (индекс: %d)',
 //   [stationCount, CurrentStationName, currentStationIndex, NextStationName, nextStationIndex]));
end;


function GetTextByType(funcType: Integer): string;
begin
  case funcType of
    0: Result := ''; 
    1: Result := GetSpeed;
    2: Result := GetDistance;
    3: Result := GetCurrentDate;
    4: Result := GetCurrentTime;
    5: Result := GetPressureTM;
    6: Result := GetPressureUR;
    7: Result := GetPressureTC;
    8: Result := GetAcceleration;
    9: Result := GetCoordinatesFormatted;
    10: Result := GetTrackNumber;
    11: Result := GetLimitSpeed;
    12: begin
      // Обновляем станции только по таймеру
      if (timeGetTime - LastStationCheck) > StationCheckInterval then
      begin
        FindCurrentAndNextStation;
        CachedCurrentStation := CurrentStationName;
        CachedNextStation := NextStationName;
        LastStationCheck := timeGetTime;
      end;
      Result := 'ЗАДАНИЕ: ' + CachedCurrentStation;
    end;
    13: Result := 'РАСПИСАНИЕ';
    14: begin
      Result := CurrentStationName;
    end;
    15: begin
      Result := NextStationName;
    end;
    
    // Новые функции для цифр скорости (20-22)
    20: Result := GetSpeedDigit(1);     // 1-я позиция скорости
    21: Result := GetSpeedDigit(2);     // 2-я позиция скорости  
    22: Result := GetSpeedDigit(3);     // 3-я позиция скорости
    
    // Новые функции для цифр допустимой скорости (23-25)
    23: Result := GetLimitSpeedDigit(1); // 1-я позиция допустимой
    24: Result := GetLimitSpeedDigit(2); // 2-я позиция допустимой
    25: Result := GetLimitSpeedDigit(3); // 3-я позиция допустимой
    
    // Новые функции для цифр расстояния (26-29)
    26: Result := GetDistanceDigit(1);   // 1-я позиция расстояния
    27: Result := GetDistanceDigit(2);   // 2-я позиция расстояния
    28: Result := GetDistanceDigit(3);   // 3-я позиция расстояния
    29: Result := GetDistanceDigit(4);   // 4-я позиция расстояния
    
    // Функции для светофорной системы (30-33) - добавь свою логику
    30, 31, 32, 33: Result := ''; // Здесь добавь логику для светофоров

    34: Result := GetFloatDigit(1);  // 1-я позиция float
    35: Result := GetFloatDigit(2);  // 2-я позиция float

    else Result := '';
  end;
end;

// Функция для проверки, нужно ли отображать цифру в позиции
function ShouldShowDigit(funcType: Integer): Boolean;
var
  speedValue, limitValue, distanceValue: Integer;
  speedStr, limitStr, distanceStr: string;
begin
  Result := True; // По умолчанию показываем
  
  try
    case funcType of
      // Скорость (позиции 1, 2, 3)
      20..22: begin
        speedValue := GetSpeedValue; // Используем новую функцию
        speedStr := IntToStr(speedValue);
        
        case funcType of
          20: Result := Length(speedStr) >= 3; // 1-я позиция - только если 3+ цифр (100+)
          21: Result := Length(speedStr) >= 2; // 2-я позиция - только если 2+ цифр (10+)
          22: Result := Length(speedStr) >= 1; // 3-я позиция - всегда
        end;
      end;
      
      // Допустимая скорость (позиции 1, 2, 3)
      23..25: begin
        limitValue := GetLimitSpeedValue; // Используем функцию из KlubData
        limitStr := IntToStr(limitValue);
        
        case funcType of
          23: Result := Length(limitStr) >= 3; // 1-я позиция - только если 3+ цифр (100+)
          24: Result := Length(limitStr) >= 2; // 2-я позиция - только если 2+ цифр (10+)
          25: Result := Length(limitStr) >= 1; // 3-я позиция - всегда
        end;
      end;
      
      // Расстояние до цели (позиции 1, 2, 3, 4)
      26..29: begin
        distanceValue := GetDistanceValue; // Используем новую функцию
        distanceStr := IntToStr(distanceValue);
        
        case funcType of
          26: Result := Length(distanceStr) >= 4; // 1-я позиция - только если 4+ цифр (1000+)
          27: Result := Length(distanceStr) >= 3; // 2-я позиция - только если 3+ цифр (100+)
          28: Result := Length(distanceStr) >= 2; // 3-я позиция - только если 2+ цифр (10+)
          29: Result := Length(distanceStr) >= 1; // 4-я позиция - всегда
        end;
      end;
      34..35: begin
        case funcType of
          34: Result := ShouldShowFloatDigit(1); // 1-я позиция
          35: Result := ShouldShowFloatDigit(2); // 2-я позиция
        end;
      end;

    end;
  except
    Result := False;
  end;
end;

// Обновленная функция DrawObject
procedure DrawObject(o: TObjectParams; ElementIndex: Integer = -1);
var
  textToShow: string;
  fontToUse: Integer;
  shouldDraw: Boolean;
begin
  // Проверяем, нужно ли отображать этот элемент
  shouldDraw := True;
  
  if ElementIndex >= 0 then
 begin
    case ElementIndex of
      0..13: shouldDraw := Config_BGSD;     // Основные данные
      14..27: shouldDraw := Config_SAUT;    // ← ИСПРАВЛЕНО: только цифры скорости и лимитов
      28..29: shouldDraw := Config_BGSD;    // "следует графику" 
      30..33: shouldDraw := Config_BGSD;    // Задание/Расписание
      34..35: shouldDraw := Config_STUPEN;  // Ступени отдельно
    end;
  end;
  
  // Если элемент отключен в конфиге, не рисуем его
  if not shouldDraw then Exit;
  
  // Дополнительная проверка для цифр - показывать только нужные позиции
  if (o.FuncType >= 20) and (o.FuncType <= 29) then
  begin
    if not ShouldShowDigit(o.FuncType) then Exit;
  end;

  // Проверка для float цифр (ступени)
  if (o.FuncType >= 34) and (o.FuncType <= 35) then
  begin
    if not ShouldShowFloatDigit(o.FuncType - 33) then Exit; // 34->1, 35->2
  end;

  if o.FuncType = 0 then
    textToShow := o.Text
  else
    textToShow := GetTextByType(o.FuncType);

  // Выбор шрифта
  if ((ElementIndex >= 14) and (ElementIndex <= 23)) or  // цифры скорости и лимитов
     ((ElementIndex >= 34) and (ElementIndex <= 35)) then // float цифры
    fontToUse := ImpactFont  // 7-Segment для всех цифр
  else
    fontToUse := KLUBUFont;  // KLUBU для остальных
    
  BeginObj3D;
  Position3D(o.X, o.Y, o.Z);
  RotateX(o.RotX);
  RotateY(o.RotY);
  RotateZ(o.RotZ);
  Scale3D(o.Scale);
  SetTexture(0);
  Color3D(o.Color, 255, False, 0);
  DrawText3D(fontToUse, textToShow);
  EndObj3D;
end;


function SafeStrToFloat(const S: string): Single;
begin
  Result := StrToFloat(StringReplace(S, '.', ',', [rfReplaceAll]));
end;


// ===== ФУНКЦИЯ СОЗДАНИЯ ПАПОК =====
function CreateDirectoryPath(const DirPath: string): Boolean;
var
  i: Integer;
  currentPath: string;
begin
  Result := True;
  currentPath := '';
  
  for i := 1 to Length(DirPath) do
  begin
    if (DirPath[i] = '\') or (i = Length(DirPath)) then
    begin
      if i = Length(DirPath) then
        currentPath := currentPath + DirPath[i];
        
      if not DirectoryExists(currentPath) then
      begin
        try
          CreateDir(currentPath);
        except
          Result := False;
          Exit;
        end;
      end;
      
      if i < Length(DirPath) then
        currentPath := currentPath + '\';
    end
    else
      currentPath := currentPath + DirPath[i];
  end;
end;

// ===== ФУНКЦИЯ ПОЛУЧЕНИЯ ПУТИ К ЭЛЕМЕНТАМ =====
function GetElementsPath: string;
var
  locFolder: string;
  locType: Integer;
begin
  locType := GetLocomotiveTypeFromMemory;
  locFolder := GetLocomotiveFolder(locType);
  Result := 'data\' + locFolder + '\' + LocNum + '\raildriver\';
  
  // ДОБАВЛЯЕМ ОТЛАДКУ
  AddToLogFile(EngineLog, '=== DEBUG GetElementsPath ===');
  AddToLogFile(EngineLog, 'LocType from memory: ' + IntToStr(locType));
  AddToLogFile(EngineLog, 'LocFolder: ' + locFolder);
  AddToLogFile(EngineLog, 'LocNum: ' + LocNum);
  AddToLogFile(EngineLog, 'Generated path: ' + Result);
  AddToLogFile(EngineLog, 'Directory exists: ' + BoolToStr(DirectoryExists(Result), True));
end;

// ===== ЗАГРУЗКА ПАРАМЕТРОВ СТРЕЛКИ ИЗ НОВОЙ ПАПКИ =====
procedure LoadArrowParams(ForceReload: Boolean = False);
var
  f: TextFile;
  line: string;
  paramName, paramValue: string;
  colonPos: Integer;
  currentTime: Cardinal;
  arrowFilePath, elementsPath: string;
begin
  currentTime := timeGetTime;
  
  // Проверяем, нужно ли обновлять (по таймеру или принудительно)
  if not ForceReload and ArrowParamsLoaded and 
     ((currentTime - LastArrowParamsCheck) < ArrowParamsCheckInterval) then
    Exit;
  
  // Значения по умолчанию
  ArrowAngle := 150.0;
  ArrowRotation := 90.0;
  ArrowScale := 1.61;
  ArrowX := 0.895;
  ArrowY := 7.45;
  ArrowZ := 3.64;
  ArrowRotateX := -40.4;
  ArrowRotateY := 0.0;
  ArrowRotateZ := 0.0;
  ArrowCurrentSpeed := 0.0;
  ArrowKoef := 1.63;
  
  // Получаем путь к файлу
  elementsPath := GetElementsPath;
  arrowFilePath := elementsPath + 'arrow_usavpp.txt';
  
  // ОТЛАДКА ПУТЕЙ
  AddToLogFile(EngineLog, '=== LoadArrowParams DEBUG ===');
  AddToLogFile(EngineLog, 'Elements path: ' + elementsPath);
  AddToLogFile(EngineLog, 'Arrow file path: ' + arrowFilePath);
  AddToLogFile(EngineLog, 'Elements directory exists: ' + BoolToStr(DirectoryExists(elementsPath), True));
  AddToLogFile(EngineLog, 'Arrow file exists: ' + BoolToStr(FileExists(arrowFilePath), True));
  
  if FileExists(arrowFilePath) then
  begin
    try
      AddToLogFile(EngineLog, 'Попытка загрузки arrow_usavpp.txt...');
      AssignFile(f, arrowFilePath);
      Reset(f);
      
      while not Eof(f) do
      begin
        ReadLn(f, line);
        line := Trim(line);
        
        // Пропускаем пустые строки и комментарии
        if (line = '') or (line[1] = '#') or (line[1] = ';') then Continue;
        
        colonPos := Pos(':', line);
        if colonPos > 0 then
        begin
          paramName := LowerCase(Trim(Copy(line, 1, colonPos - 1)));
          paramValue := Trim(Copy(line, colonPos + 1, Length(line)));
          
          AddToLogFile(EngineLog, 'Читаем параметр: ' + paramName + ' = ' + paramValue);
          
          try
            if paramName = 'arrowangle' then
              ArrowAngle := SafeStrToFloat(paramValue)
            else if paramName = 'arrowrotation' then
              ArrowRotation := SafeStrToFloat(paramValue)
            else if paramName = 'arrowscale' then
              ArrowScale := SafeStrToFloat(paramValue)
            else if paramName = 'arrowx' then
              ArrowX := SafeStrToFloat(paramValue)
            else if paramName = 'arrowy' then
              ArrowY := SafeStrToFloat(paramValue)
            else if paramName = 'arrowz' then
              ArrowZ := SafeStrToFloat(paramValue)
            else if paramName = 'arrowrotatex' then
              ArrowRotateX := SafeStrToFloat(paramValue)
            else if paramName = 'arrowrotatey' then
              ArrowRotateY := SafeStrToFloat(paramValue)
            else if paramName = 'arrowrotatez' then
              ArrowRotateZ := SafeStrToFloat(paramValue)
            else if paramName = 'currentspeed' then
              ArrowCurrentSpeed := SafeStrToFloat(paramValue)
            else if paramName = 'koef' then
              ArrowKoef := SafeStrToFloat(paramValue)
            else if paramName = 'updateinterval' then
            begin
              ArrowParamsCheckInterval := Round(SafeStrToFloat(paramValue));
              if ArrowParamsCheckInterval < 50 then ArrowParamsCheckInterval := 50;
              if ArrowParamsCheckInterval > 5000 then ArrowParamsCheckInterval := 5000;
            end;
          except
            on E: Exception do
              AddToLogFile(EngineLog, 'Ошибка преобразования параметра ' + paramName + ': ' + E.Message);
          end;
        end;
      end;
      
      CloseFile(f);
      AddToLogFile(EngineLog, 'arrow_usavpp.txt успешно загружен');
      
    except
      on E: Exception do
      begin
        AddToLogFile(EngineLog, 'КРИТИЧЕСКАЯ ОШИБКА загрузки arrow_usavpp.txt: ' + E.Message);
        try
          CloseFile(f);
        except
        end;
      end;
    end;
  end
  else
  begin
    AddToLogFile(EngineLog, 'arrow_usavpp.txt НЕ НАЙДЕН по пути: ' + arrowFilePath);
    
    // Создаем файл и папки только при первой загрузке
    if not ArrowParamsLoaded then
    begin
      try
        AddToLogFile(EngineLog, 'Попытка создания папки: ' + elementsPath);
        // Создаем папки если их нет
        if CreateDirectoryPath(elementsPath) then
        begin
          AddToLogFile(EngineLog, 'Папка создана успешно, создаем arrow_usavpp.txt');
          AssignFile(f, arrowFilePath);
          Rewrite(f);
          WriteLn(f, '# Конфигурация параметров стрелки спидометра УСАВП');
          WriteLn(f, '# Используйте точку как разделитель десятичных');
          WriteLn(f, '');
          WriteLn(f, '# Интервал обновления файла в миллисекундах (50-5000)');
          WriteLn(f, 'updateInterval: ', ArrowParamsCheckInterval);
          WriteLn(f, '');
          WriteLn(f, '# Угол стрелки (базовый)');
          WriteLn(f, 'arrowAngle: 150.0');
          WriteLn(f, '');
          WriteLn(f, '# Поворот стрелки');
          WriteLn(f, 'arrowRotation: 90.0');
          WriteLn(f, '');
          WriteLn(f, '# Масштаб стрелки');
          WriteLn(f, 'arrowScale: 1.61');
          WriteLn(f, '');
          WriteLn(f, '# Позиция стрелки');
          WriteLn(f, 'arrowX: 0.895');
          WriteLn(f, 'arrowY: 7.45');
          WriteLn(f, 'arrowZ: 3.64');
          WriteLn(f, '');
          WriteLn(f, '# Поворот по оси X');
          WriteLn(f, 'arrowRotateX: -40.4');
          WriteLn(f, '');
          WriteLn(f, '# Поворот по оси Y');
          WriteLn(f, 'arrowRotateY: 0.0');
          WriteLn(f, '');
          WriteLn(f, '# Поворот по оси Z');
          WriteLn(f, 'arrowRotateZ: 0.0');
          WriteLn(f, '');
          WriteLn(f, '# Текущая скорость (для расчета угла)');
          WriteLn(f, 'currentSpeed: 0.0');
          WriteLn(f, '');
          WriteLn(f, '# Коэффициент (множитель скорости)');
          WriteLn(f, 'koef: 1.63');
          CloseFile(f);
          AddToLogFile(EngineLog, 'arrow_usavpp.txt создан успешно: ' + arrowFilePath);
        end
        else
        begin
          AddToLogFile(EngineLog, 'ОШИБКА создания папки: ' + elementsPath);
        end;
      except
        on E: Exception do
          AddToLogFile(EngineLog, 'ОШИБКА создания arrow_usavpp.txt: ' + E.Message);
      end;
    end;
  end;
  
  ArrowParamsLoaded := True;
  LastArrowParamsCheck := currentTime;
  
  AddToLogFile(EngineLog, Format('Финальные параметры стрелки: Angle=%.2f, X=%.3f, Y=%.3f, Z=%.3f',
    [ArrowAngle, ArrowX, ArrowY, ArrowZ]));
end;

// ===== ЗАГРУЗКА НАСТРОЕК ОТОБРАЖЕНИЯ ИЗ BOOSTER.TXT =====
procedure LoadBoosterConfig(ForceReload: Boolean = False);
var
  f: TextFile;
  line: string;
  paramName, paramValue: string;
  colonPos: Integer;
  currentTime: Cardinal;
  boosterFilePath, elementsPath: string;
begin
  currentTime := timeGetTime;
  
  // Проверяем, нужно ли обновлять
  if not ForceReload and ConfigLoaded and 
     ((currentTime - LastBoosterConfigCheck) < BoosterConfigCheckInterval) then
    Exit;
  
  // Значения по умолчанию
  Config_SAUT := False;
  Config_BGSD := True;
  Config_STUPEN := True;
  
  // Получаем путь к файлу
  elementsPath := GetElementsPath;
  boosterFilePath := elementsPath + 'booster.txt';
  
  // ОТЛАДКА ПУТЕЙ
  AddToLogFile(EngineLog, '=== LoadBoosterConfig DEBUG ===');
  AddToLogFile(EngineLog, 'Elements path: ' + elementsPath);
  AddToLogFile(EngineLog, 'Booster file path: ' + boosterFilePath);
  AddToLogFile(EngineLog, 'Elements directory exists: ' + BoolToStr(DirectoryExists(elementsPath), True));
  AddToLogFile(EngineLog, 'Booster file exists: ' + BoolToStr(FileExists(boosterFilePath), True));
  
  if FileExists(boosterFilePath) then
  begin
    try
      AddToLogFile(EngineLog, 'Попытка загрузки booster.txt...');
      AssignFile(f, boosterFilePath);
      Reset(f);
      
      while not Eof(f) do
      begin
        ReadLn(f, line);
        line := Trim(line);
        
        // Пропускаем пустые строки и комментарии
        if (line = '') or (line[1] = '#') or (line[1] = ';') then Continue;
        
        colonPos := Pos(':', line);
        if colonPos > 0 then
        begin
          paramName := LowerCase(Trim(Copy(line, 1, colonPos - 1)));
          paramValue := Trim(Copy(line, colonPos + 1, Length(line)));
          
          AddToLogFile(EngineLog, 'Читаем параметр: ' + paramName + ' = ' + paramValue);
          
          try
            if paramName = 'saut' then
            begin
              Config_SAUT := (paramValue = '1') or (LowerCase(paramValue) = 'true');
              AddToLogFile(EngineLog, 'SAUT установлен в: ' + BoolToStr(Config_SAUT, True));
            end
            else if paramName = 'bgsd' then
            begin
              Config_BGSD := (paramValue = '1') or (LowerCase(paramValue) = 'true');
              AddToLogFile(EngineLog, 'BGSD установлен в: ' + BoolToStr(Config_BGSD, True));
            end
            else if paramName = 'stupen' then
            begin
              Config_STUPEN := (paramValue = '1') or (LowerCase(paramValue) = 'true');
              AddToLogFile(EngineLog, 'STUPEN установлен в: ' + BoolToStr(Config_STUPEN, True));
            end;
          except
            on E: Exception do
              AddToLogFile(EngineLog, 'Ошибка преобразования параметра ' + paramName + ': ' + E.Message);
          end;
        end;
      end;
      
      CloseFile(f);
      AddToLogFile(EngineLog, 'booster.txt успешно загружен');
      
    except
      on E: Exception do
      begin
        AddToLogFile(EngineLog, 'КРИТИЧЕСКАЯ ОШИБКА загрузки booster.txt: ' + E.Message);
        try
          CloseFile(f);
        except
        end;
      end;
    end;
  end
  else
  begin
    AddToLogFile(EngineLog, 'booster.txt НЕ НАЙДЕН по пути: ' + boosterFilePath);
    
    // Создаем файл только при первой загрузке
    if not ConfigLoaded then
    begin
      try
        AddToLogFile(EngineLog, 'Попытка создания папки: ' + elementsPath);
        // Создаем папки если их нет
        if CreateDirectoryPath(elementsPath) then
        begin
          AddToLogFile(EngineLog, 'Папка создана успешно, создаем booster.txt');
          AssignFile(f, boosterFilePath);
          Rewrite(f);
          WriteLn(f, '# Конфигурация отображения элементов ZDBooster');
          WriteLn(f, '# 1 = включено, 0 = выключено');
          WriteLn(f, '');
          WriteLn(f, '# ===== НАСТРОЙКИ ОТОБРАЖЕНИЯ =====');
          WriteLn(f, '# Отображение скорости и лимитов (элементы 14, 15, 16)');
          WriteLn(f, 'saut: 0');
          WriteLn(f, '');
          WriteLn(f, '# Отображение основных данных (элементы 0-13)');
          WriteLn(f, 'bgsd: 1');
          WriteLn(f, '');
          WriteLn(f, '# Отображение ступеней (элементы 34-35)');
          WriteLn(f, 'stupen: 1');
          CloseFile(f);
          AddToLogFile(EngineLog, 'booster.txt создан успешно: ' + boosterFilePath);
        end
        else
        begin
          AddToLogFile(EngineLog, 'ОШИБКА создания папки: ' + elementsPath);
        end;
      except
        on E: Exception do
          AddToLogFile(EngineLog, 'ОШИБКА создания booster.txt: ' + E.Message);
      end;
    end;
  end;
  
  LastBoosterConfigCheck := currentTime;
  AddToLogFile(EngineLog, 'Финальные настройки: SAUT=' + BoolToStr(Config_SAUT, True) + 
    ', BGSD=' + BoolToStr(Config_BGSD, True) + ', STUPEN=' + BoolToStr(Config_STUPEN, True));
end;

// ===== ОБЩАЯ ФУНКЦИЯ ИНИЦИАЛИЗАЦИИ ВСЕХ КОНФИГОВ =====
procedure InitializeAllConfigs;
begin
  if not ConfigLoaded then
  begin
    LoadConfigFile;        // Загружаем настройки фрикама
    LoadBoosterConfig;     // Загружаем настройки отображения
    LoadArrowParams;       // Загружаем параметры стрелки
  end
  else
  begin
    // Обновляем в реал-тайм
    LoadBoosterConfig;     // Проверяем booster.txt
    LoadArrowParams;       // Проверяем arrow_usavpp.txt
  end;
end;


procedure LoadYellowBlockParams;
var
  f: TextFile;
  line: string;
  paramName, paramValue: string;
  colonPos: Integer;
  fileTime: TFileTime;
  handle: THandle;
  changed: Boolean;
begin
  changed := False;
  
  // Проверяем, изменился ли файл (опционально - для оптимизации)
  if FileExists('yellow_block.txt') then
  begin
    // Если файл загружался ранее, проверяем время изменения
    if YellowBlockParamsLoaded then
    begin
      // Простая проверка - загружаем каждый раз (можно оптимизировать позже)
      changed := True;
    end
    else
    begin
      changed := True; // Первая загрузка
    end;
  end;
  
  // Если файл не изменился, выходим (закомментируйте эти строки для постоянной перезагрузки)
  // if not changed then Exit;
  
  // Значения по умолчанию
  YellowBlockRotX := 0.0;
  YellowBlockRotY := 0.0;
  YellowBlockRotZ := 0.0;
  YellowBlockPosX := -0.086499996;
  YellowBlockPosY := 0.0;
  YellowBlockPosZ := 0.223;
  YellowBlockScale := 0.88999999;
  
  if FileExists('yellow_block.txt') then
  begin
    try
      AssignFile(f, 'yellow_block.txt');
      Reset(f);
      
      while not Eof(f) do
      begin
        ReadLn(f, line);
        line := Trim(line);
        
        // Пропускаем пустые строки и комментарии
        if (line = '') or (line[1] = '#') then Continue;
        
        colonPos := Pos(':', line);
        if colonPos > 0 then
        begin
          paramName := LowerCase(Trim(Copy(line, 1, colonPos - 1)));
          paramValue := Trim(Copy(line, colonPos + 1, Length(line)));
          
          try
            if paramName = 'rotx' then
              YellowBlockRotX := SafeStrToFloat(paramValue)
            else if paramName = 'roty' then
              YellowBlockRotY := SafeStrToFloat(paramValue)
            else if paramName = 'rotz' then
              YellowBlockRotZ := SafeStrToFloat(paramValue)
            else if paramName = 'posx' then
              YellowBlockPosX := SafeStrToFloat(paramValue)
            else if paramName = 'posy' then
              YellowBlockPosY := SafeStrToFloat(paramValue)
            else if paramName = 'posz' then
              YellowBlockPosZ := SafeStrToFloat(paramValue)
            else if paramName = 'scale' then
              YellowBlockScale := SafeStrToFloat(paramValue);
          except
            //AddToLogFile(EngineLog, 'Ошибка чтения параметра: ' + paramName + ' = ' + paramValue);
          end;
        end;
      end;
      
      CloseFile(f);

    except
      on E: Exception do
      begin
   //     AddToLogFile(EngineLog, 'Ошибка загрузки yellow_block.txt: ' + E.Message);
        try
          CloseFile(f);
        except
        end;
      end;
    end;
  end;

  YellowBlockParamsLoaded := True;
end;

begin


//    ProcessFreecam;

//if not HookAddressWritten then
//begin
//  WriteHookAddress;  // ← ВОТ ЗДЕСЬ ВЫЗЫВАЕТСЯ
//  HookAddressWritten := True;
//end;

SetLight(5, cos((90.0 - 54254 * 15.0 / 3600.0) * 3.141592653589793238 / 180.0) * 700.0,
 sin((90.0 - 54254 * 15.0 / 3600.0) * 3.141592653589793238 / 180.0) * 700.0, 200.0, $FFFFFF,
  9000.0, False, 10.0);



  // ===== ИНИЦИАЛИЗАЦИЯ СВЕТОФОРНОЙ СИСТЕМЫ =====
if not SystemInitialized then
  begin
    InitializeTrafficLightSystem;
    LoadBoosterConfig;
    try
      baseStructAddr := PCardinal(Pointer($00400000 + $8D10D70))^;
      CachedYellowBlockID := PWord(Pointer(baseStructAddr + $1A))^;
      CachedGreenBlockID := PWord(Pointer(baseStructAddr + $1C))^;
      LightBlockIDsCached := True;
    except
      CachedYellowBlockID := 13;
      CachedGreenBlockID := 14;
      LightBlockIDsCached := True;
    end;
    SystemInitialized := True;
  end;
  //LoadYellowBlockParams;

  if not LightBlockIDsCached then
  begin
    try
      baseStructAddr := PCardinal(Pointer($00400000 + $8D10D70))^;
      CachedYellowBlockID := PWord(Pointer(baseStructAddr + $1A))^;
      CachedGreenBlockID := PWord(Pointer(baseStructAddr + $1C))^;
      LightBlockIDsCached := True;
      
   //   AddToLogFile(EngineLog, Format('Кэшированы ID: Желтый=%d, Зеленый=%d',
   //     [CachedYellowBlockID, CachedGreenBlockID]));
    except
      // При ошибке используем значения по умолчанию
      CachedYellowBlockID := 13;
      CachedGreenBlockID := 14;
      LightBlockIDsCached := True;
    end;
  end;


  // ===== ОБРАБОТКА КЛАВИАТУРЫ =====
if (timeGetTime - LastKeyboardCheck) > KeyboardCheckInterval then
begin
  NewCommandReceived := ProcessKeyboard;
  LastKeyboardCheck := timeGetTime;
end;

  // ===== ОБРАБОТКА КОМАНДЫ 137 =====
  
  // Проверяем новую команду "137" только если она еще не активна
  if NewCommandReceived and (LastCommand = '137') and not statek137 then
  begin
    statek137 := True;
    SavedCommand := LastCommand;
    CommandCompleted := False;
    
    //AddToLogFile(EngineLog, 'Активируем команду "137"');

    if WriteAndVerify($00400000 + $34988C, 52) then
    begin
      //AddToLogFile(EngineLog, 'Команда "137" успешно активирована');
      CommandBuffer := ''; // ← ОЧИЩАЕМ БУФЕР СРАЗУ!
      EnterPressed := False;
    end
    else
    begin
      //AddToLogFile(EngineLog, 'ОШИБКА активации команды "137"');
      statek137 := False;
      CommandBuffer := '';
    end;
  end;

  // Отображаем интерфейс команды 137
  if statek137 and not CommandCompleted then
  begin
    BeginObj3D;
    Position3D(1.125, 7.22, 3.574);
    RotateX(-90.0);
    RotateY(45.0);
    Scale3D(0.011);
    Color3D(3407667, 255, False, 0.0);
    SetTexture(0);
    DrawText3D(0, 'ТАБЛИЦА АЛС-ЕН');
    EndObj3D;
  end;


  // Завершаем команду 137 при повторном нажатии ENTER
  if statek137 and not CommandCompleted and EnterPressed then
  begin
    //AddToLogFile(EngineLog, 'Завершаем команду "137"');
    
    if WriteAndVerify($00400000 + $34988C, 30) then
    begin
      // ПРОВЕРЯЕМ И СОХРАНЯЕМ ВВЕДЕННОЕ ЧИСЛО В en_chastota
try
  if (CommandBuffer <> '') and (StrToInt(CommandBuffer) <= 3) and (StrToInt(CommandBuffer) > 0) then
  begin
    en_chastota := CommandBuffer + 'ЕН';
    als_en_state := True;
  end
  else
  begin
    en_chastota := 'x';
    als_en_state := False;
  end;
except
  en_chastota := 'x'; // На случай ошибки преобразования
  als_en_state := False;
end;


      
      CommandCompleted := True;
      statek137 := False;
      CommandBuffer := '';
      
      ///AddToLogFile(EngineLog, 'ТАБЛИЦА АЛС-ЕН: ' + SavedCommand);
      //AddToLogFile(EngineLog, 'Сохранено значение частоты: ' + en_chastota);
      
  //    AddToLogFile(EngineLog, 'Команда "137" успешно завершена');
      SavedCommand := '';
    end
    else
    begin
      //AddToLogFile(EngineLog, 'ОШИБКА завершения команды "137"');
    end;
  end;

 // ===== ОБРАБОТКА КОМАНДЫ 10 ===== <- НОВЫЙ БЛОК
  
  // Проверяем новую команду "10" только если она еще не активна
  if NewCommandReceived and (LastCommand = '10') and not statek10 then
  begin
    statek10 := True;
    SavedCommand := LastCommand;
    CommandCompleted := False;
    
    if WriteAndVerify($00400000 + $34988C, 53) then  // Попробуй 53, потом 54 если не работает
    begin
      CommandBuffer := '';
      EnterPressed := False;
    end
    else
    begin
      statek10 := False;
      CommandBuffer := '';
    end;
  end;

  // Отображаем интерфейс команды 10
  if statek10 and not CommandCompleted then
  begin
    BeginObj3D;
    Position3D(1.125, 7.22, 3.574);
    RotateX(-90.0);
    RotateY(45.0);
    Scale3D(0.011);
    Color3D(3407667, 255, False, 0.0);
    SetTexture(0);
    DrawText3D(0, 'K:raildriver');  // <- ДРУГОЙ ТЕКСТ
    EndObj3D;
  end;

  // Завершаем команду 10 при повторном нажатии ENTER
  if statek10 and not CommandCompleted and EnterPressed then
  begin
    if WriteAndVerify($00400000 + $34988C, 30) then
    begin
      CommandCompleted := True;
      statek10 := False;
      CommandBuffer := '';
      
      AddToLogFile(EngineLog, 'Команда "10" успешно завершена');
      SavedCommand := '';
    end
    else
    begin
      //AddToLogFile(EngineLog, 'ОШИБКА завершения команды "10"');
    end;
  end;
  // ===== КОНЕЦ НОВОГО БЛОКА =====




  // ======== ИНИЦИАЛИЗАЦИЯ ========
  initialized := False;

  // Создание шрифта Impact
  if ImpactFont = 0 then
    ImpactFont := CreateFont3D('7-Segment');

  if KLUBUFont = 0 then
    KLUBUFont := CreateFont3D('KLUBU');  // ← ЗАГРУЗКА ШРИФТА KLUBU

  // Инициализация данных
  InitializeStaticData;
  
  // Загрузка моделей
  if MyModelID = 0 then
  begin
    MyModelID := LoadModel('data\loc\klub_bil_v.dmd', 0, False);
    MyTextureID := LoadTextureFromFile('data\loc\klub_bil.bmp', 0, -1);
    strelka := LoadModel('data\2te10u\0071\strelka_temp.dmd', 0, False);
  end;   

  // Получаем текущую скорость
  try
    currentSpeed := PSingle(BaseAddress + $4F8C28C)^;
    currentSpeed := Abs(currentSpeed);
  except
    currentSpeed := 0;
  end;

  // ======== АНАЛИЗ СВЕТОФОРОВ ========
if (timeGetTime - LastSignalUpdate) > SignalUpdateInterval then
begin
  CachedSignalSequence := GetSignalSequence;
  LastSignalUpdate := timeGetTime;
end;
signalSequence := CachedSignalSequence; // используем кэш
  
  // ======== ОТРИСОВКА МОДЕЛЕЙ ========



  // Частота ЕН
  BeginObj3D;
  Position3D(1.137, 7.214, 3.553);
  RotateX(-90.0);
  RotateY(45.0);
  Scale3D(0.011);
  Color3D(3407667, 255, False, 0.0);
  SetTexture(0);
  DrawText3D(0, en_chastota);
  EndObj3D;


try
  textureAddr := Pointer(PCardinal(Pointer($9110D60))^ + $34);
  textureID := PWord(textureAddr)^;
except
  textureID := MyTextureID; // fallback
end;

try
  modelAddr := Pointer(PCardinal(Pointer($00400000 + $8D10D70))^ + $04);
  modelID := PWord(modelAddr)^;
except
  modelID := MyModelID; // fallback
end;


BeginObj3D;
Position3D(1.17, 7.1799998, 3.4319999);
RotateZ(x);
SetTexture(textureID);
DrawModel(modelID, 0, False);
EndObj3D;




// ======== ЛОГИКА ОТОБРАЖЕНИЯ СВЕТОФОРОВ (ДВЕ СИСТЕМЫ) ========

    if (PByte($905B754)^ <> 0) and (als_en_state) then
      begin
        BeginObj3D;
        Position3D(1.111, 7.239, 3.729);
        RotateX(-90.0);
        RotateY(40.0);
        RotateZ(-90.0);
        Scale3D(0.015);
        Color3D($FF00FF00, 255, False, 0.0);
        SetTexture(0);
        DrawText3D(0, '|');
        EndObj3D;

        BeginObj3D;
        Position3D(1.113, 7.237, 3.733);
        RotateX(-90.0);
        RotateY(40.0);
        RotateZ(-90.0);
        Scale3D(0.015);
        Color3D($FF00FF00, 255, False, 0.0);
        SetTexture(0);
        DrawText3D(0, 'l');
        EndObj3D;

        BeginObj3D;
        Position3D(1.107, 7.243, 3.7283);
        RotateX(-90.0);
        RotateY(40.0);
        RotateZ(-55.0);
        Scale3D(0.018);
        Color3D($FF00FF00, 255, False, 0.0);
        SetTexture(0);
        DrawText3D(0, '-');
        EndObj3D;
      end
    else if (als_en_state) then
         
      begin
        BeginObj3D;
        Position3D(1.111, 7.239, 3.739);
        RotateX(-90.0);
        RotateY(40.0);
        RotateZ(-90.0);
        Scale3D(0.015);
        Color3D($FF00FF00, 255, False, 0.0);
        SetTexture(0);
        DrawText3D(0, '||');
        EndObj3D;
      end;

BeginObj3D;
//SETTEXTURE($1A);

  // Получаем состояние основного светофора
  mainTrafficLight := PByte(Pointer($400000 + $8C07ECC))^;

  // Показываем блоки ТОЛЬКО при mainTrafficLight == 5
  if (mainTrafficLight = 5) and (als_en_state) and (PByte($905B754)^ = 0) then
  begin
    // ИСПРАВЛЕННАЯ ЛОГИКА: Подсчитываем видимые сигналы ДО первого КРАСНОГО (К)
    visibleSignalCount := 0;

    // Сначала найдем позицию красного сигнала или конец строки
    signalIndex := Length(signalSequence);
    for i := 1 to Length(signalSequence) do
    begin
      if signalSequence[i] = 'К' then  // ← ИЗМЕНЕНО: ищем красный вместо черного
      begin
        signalIndex := i - 1; // Берем все символы ДО красного
        Break;
      end;
    end;
    
    // Теперь считаем видимые сигналы (Ж и З) в диапазоне от 1 до signalIndex
    for i := 1 to signalIndex do
    begin
      signalChar := signalSequence[i];
      if (signalChar = 'Ж') or (signalChar = 'З') then
        Inc(visibleSignalCount);
    end;

    try
      // Получаем базовый адрес структуры
      baseStructAddr := PCardinal(Pointer($00400000 + $8D10D70))^;
      
      // Читаем ID желтого блока светофора - klub_ls_zh.dmd
      yellowBlockModelAddr := Pointer(baseStructAddr + $1A);
      yellowBlockModelID := PWord(yellowBlockModelAddr)^;
      
      // Читаем ID зеленого блока светофора - klub_ls_z.dmd  
      greenBlockModelAddr := Pointer(baseStructAddr + $1C);
      greenBlockModelID := PWord(greenBlockModelAddr)^;

    except
      // В случае ошибки используем значения по умолчанию
      yellowBlockModelID := $0D; // 13
      greenBlockModelID := $0E;  // 14
    end;



    // ======== СИСТЕМА КЛУБ (старые координаты) ========
    if visibleSignalCount > 0 then
    begin
      // Нижний блок - желтый
      BeginObj3D;
      Position3D(1.17, 7.1799998, 3.4319999);
      RotateZ(x);
      Position3D(-0.086499996, 0.0, 0.223);
      Scale3D(0.88999999);
      DrawModel(yellowBlockModelID, 0, False); // Читаем из памяти
      EndObj3D;

      // Остальные блоки выше - зеленые
      for i := 1 to visibleSignalCount - 1 do
      begin
        BeginObj3D;
        Position3D(1.17, 7.1799998, 3.4319999);
        RotateZ(x);
        Position3D(-0.086499996, 0.0, 0.223 + i * 0.013);
        Scale3D(0.88999999);
        DrawModel(greenBlockModelID, 0, False); // Читаем из памяти
        EndObj3D;

        if i >= 4 then Break; // Ограничиваем максимум 5 блоков
      end;
    end;

    SetLight(5, cos((90.0 - 54254 * 15.0 / 3600.0) * 3.141592653589793238 / 180.0) * 700.0,
     sin((90.0 - 54254 * 15.0 / 3600.0) * 3.141592653589793238 / 180.0) * 700.0, 200.0, $FFFFFF,
      9000.0, False, 10.0);

    // ======== СИСТЕМА БИЛ ПОМЕ (новые координаты) ========
    if visibleSignalCount > 0 then
    begin
      // Желтый блок (нижний по Z=3.631)
      BeginObj3D;
      Position3D(0.002, 7.515, 3.631);
      RotateX(-30);
      Scale3D(1.0);
      DrawModel(yellowBlockModelID, 0, False); // Читаем из памяти
      EndObj3D;

      // Зеленый блок 1
      if visibleSignalCount > 1 then
      begin
        BeginObj3D;
        Position3D(0.002, 7.508, 3.6438);
        RotateX(-30);
        Scale3D(1.0);
        DrawModel(CachedGreenBlockID, 0, False); // Читаем из памяти
        EndObj3D;
      end;
      
      // Зеленый блок 2  
      if visibleSignalCount > 2 then
      begin
        BeginObj3D;
        Position3D(0.00160, 7.5, 3.6576);
        RotateX(-30);
        Scale3D(1.0);
        DrawModel(greenBlockModelID, 0, True); // Читаем из памяти
        EndObj3D;
      end;

      // Зеленый блок 3
      if visibleSignalCount > 3 then
      begin
        BeginObj3D;
        Position3D(0.00160, 7.492, 3.67);
        RotateX(-30);
        Scale3D(1.0);
        DrawModel(greenBlockModelID, 0, True); // Читаем из памяти
        EndObj3D;
      end;
      
      // Зеленый блок 4
      if visibleSignalCount > 4 then
      begin
        BeginObj3D;
        Position3D(0.00160, 7.4847, 3.684);
        RotateX(-30);
        Scale3D(1.0);
        DrawModel(greenBlockModelID, 0, True); // Читаем из памяти
        EndObj3D;
      end;
    end;
  end;

  EndObj3D;

if not MemoryWritten then
begin
  WriteAndVerify($00400000 + $349898, 255);
  MemoryWritten := True;
end;

  // Дополнительный элемент
//  BeginObj3D;
//  Position3D(1.17, 0.223, 3.4319999);
//  Color3D($FFFFFF, 254, False, 0.0);
//  Scale3D(-0.086499996);
//  SetTexture(50);
//  DrawModel(38, 0, False);
//  DrawCube(0.3, 0.3, 0.3);
//  EndObj3D;

  //InitializeAllConfigs;

  // ===== ОТРИСОВКА СТРЕЛКИ С НОВЫМИ ПАРАМЕТРАМИ =====

if Config_BGSD then  // ← ДОБАВИЛИ ПРОВЕРКУ
begin
  if StrToFloat(GetSpeed) <= 90 then
     ArrowKoef := 1.63
  else
    ArrowKoef := 1.68;

  speedAngle := 155 - StrToFloat(GetSpeed) * ArrowKoef;

  BeginObj3D;
  Position3D(0.8970, 7.448, 3.6407);
  RotateX(-10.4);
  RotateY(0);
  RotateZ(x + -10.0);
  SetTexture(0);
  Color3D($ffffffff, 255, False, 0.0);
  RotateY(155.0);
  Scale3D(1.61);
  DrawModel(strelka, 0, False);
  EndObj3D;
end;

//  speedAngle := ArrowAngle - ArrowCurrentSpeed * ArrowKoef;
//
//  BeginObj3D;
//  Position3D(ArrowX, ArrowY, ArrowZ);
//  RotateX(ArrowRotateX);
//  RotateY(ArrowRotateY);
//  RotateZ(x + ArrowRotateZ);
//  SetTexture(0);
//  Color3D($ffffffff, 255, False, 0.0);
//  RotateY(speedAngle);
//  Scale3D(ArrowScale);
//  DrawModel(strelka, 0, False);
//  EndObj3D;

if Config_BGSD then  // ← ДОБАВИЛИ ПРОВЕРКУ
begin
  // Получаем значение ALS
  alsValue := GetALS;
  
  if alsValue = 3 then
  begin
    // Красно-желтый диск (рисуем два полукруга)
    
    // Верхняя половина - красная
    BeginObj3D;
    Position3D(0.8958, 7.4479, 3.6385);
    RotateX(-103.0);
    RotateY(34.2);
    Scale3D(0.0002);
    Color3D($00FFFF, 255, False, 0.0); //    Желтый
    SetTexture(0);
    Draw3DSemiCircle(52, 0, 180); // Верхний полукруг
    EndObj3D;
    
    // Нижняя половина - желтая
    BeginObj3D;
    Position3D(0.8958, 7.4479, 3.6385);
    RotateX(-103.0);
    RotateY(34.2);
    Scale3D(0.0002);
    Color3D($0000FF, 255, False, 0.0); // Красный
    SetTexture(0);
    Draw3DSemiCircle(52, 180, 360); // Нижний полукруг
    EndObj3D;
  end
  else
  begin
    // Обычный одноцветный диск
    case alsValue of
      1: diskColor := $FFFFFF;  // Белый
      2: diskColor := $0000FF;  // Красный  
      4: diskColor := $00FFFF;  // Желтый
      5: diskColor := $00FF00;  // Зеленый
      else diskColor := $808080; // Серый по умолчанию
    end;
    
    BeginObj3D;
    Position3D(0.8958, 7.4479, 3.6385);
    RotateX(-103.0);
    RotateY(34.2);
    Scale3D(0.0002);
    Color3D(diskColor, 255, False, 0.0);
    SetTexture(0);
    Draw3DDisk(52);
    EndObj3D;
  end;
end;

  // ======== ТЕКСТОВЫЕ 3D-ОБЪЕКТЫ ========
  if debug then
  begin
  for i := 0 to 35 do  // ← Здесь правильно, но в debug неправильно
    DrawObject(StaticData[i], i);
  end;

//    if signalSequence <> '' then
//    begin
//      BeginObj3D;
//      Position3D(1.0, 7.0, 3.75);
//      RotateX(-90);
//      Scale3D(0.01);
//      SetTexture(0);
//      Color3D($00FF00, 255, False, 0);
//      DrawText3D(0, 'SIG: ' + signalSequence);
//      EndObj3D;
//    end;

  // ======== ОТЛАДОЧНАЯ ИНФОРМАЦИЯ ========
  if not debug then
  begin
    if CommandBuffer <> '' then
    begin
      BeginObj3D;
      Position3D(1.0, 7.0, 3.8);
      RotateX(-90);
      Scale3D(0.01);
      SetTexture(0);
      Color3D($FF0000, 255, False, 0);
      DrawText3D(0, 'CMD: ' + CommandBuffer);
      EndObj3D;
    end;
    
    // Отображаем текущую последовательность сигналов
    if signalSequence <> '' then
    begin
      BeginObj3D;
      Position3D(1.0, 7.0, 3.75);
      RotateX(-90);
      Scale3D(0.01);
      SetTexture(0);
      Color3D($00FF00, 255, False, 0);
      DrawText3D(0, 'SIG: ' + signalSequence);
      EndObj3D;
    end;
  end;
end;


{------------------------------------------------------------------}
procedure DrawCube(Width,Height,Depth : single); stdcall;
begin
glPushMatrix();
    glScalef(Width,Height,Depth);
    glBegin(GL_QUADS);
      // Front Face
      glNormal3f( 0.0, 0.0, 1.0);
      _glTexCoord2f(0.0, 0.0); glVertex3f(-1.0, -1.0,  1.0);
      _glTexCoord2f(1.0, 0.0); glVertex3f( 1.0, -1.0,  1.0);
      _glTexCoord2f(1.0, 1.0); glVertex3f( 1.0,  1.0,  1.0);
      _glTexCoord2f(0.0, 1.0); glVertex3f(-1.0,  1.0,  1.0);
      // Back Face
      glNormal3f( 0.0, 0.0,-1.0);
      _glTexCoord2f(1.0, 0.0); glVertex3f(-1.0, -1.0, -1.0);
      _glTexCoord2f(1.0, 1.0); glVertex3f(-1.0,  1.0, -1.0);
      _glTexCoord2f(0.0, 1.0); glVertex3f( 1.0,  1.0, -1.0);
      _glTexCoord2f(0.0, 0.0); glVertex3f( 1.0, -1.0, -1.0);
      // Top Face
      glNormal3f( 0.0, 1.0, 0.0);
      _glTexCoord2f(0.0, 1.0); glVertex3f(-1.0,  1.0, -1.0);
      _glTexCoord2f(0.0, 0.0); glVertex3f(-1.0,  1.0,  1.0);
      _glTexCoord2f(1.0, 0.0); glVertex3f( 1.0,  1.0,  1.0);
      _glTexCoord2f(1.0, 1.0); glVertex3f( 1.0,  1.0, -1.0);
      // Bottom Face
      glNormal3f( 0.0,-1.0, 0.0);
      _glTexCoord2f(1.0, 1.0); glVertex3f(-1.0, -1.0, -1.0);
      _glTexCoord2f(0.0, 1.0); glVertex3f( 1.0, -1.0, -1.0);
      _glTexCoord2f(0.0, 0.0); glVertex3f( 1.0, -1.0,  1.0);
      _glTexCoord2f(1.0, 0.0); glVertex3f(-1.0, -1.0,  1.0);
      // Right face
      glNormal3f( 1.0, 0.0, 0.0);
      _glTexCoord2f(1.0, 0.0); glVertex3f( 1.0, -1.0, -1.0);
      _glTexCoord2f(1.0, 1.0); glVertex3f( 1.0,  1.0, -1.0);
      _glTexCoord2f(0.0, 1.0); glVertex3f( 1.0,  1.0,  1.0);
      _glTexCoord2f(0.0, 0.0); glVertex3f( 1.0, -1.0,  1.0);
      // Left Face
      glNormal3f(-1.0, 0.0, 0.0);
      _glTexCoord2f(0.0, 0.0); glVertex3f(-1.0, -1.0, -1.0);
      _glTexCoord2f(1.0, 0.0); glVertex3f(-1.0, -1.0,  1.0);
      _glTexCoord2f(1.0, 1.0); glVertex3f(-1.0,  1.0,  1.0);
      _glTexCoord2f(0.0, 1.0); glVertex3f(-1.0,  1.0, -1.0);
    glEnd();
glPopMatrix();
end;

end.

